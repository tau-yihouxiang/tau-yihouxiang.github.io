<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PICO 6DoF</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      color: #fff;
      background: rgb(56, 56, 62);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }

    .container {
      display: flex;
      align-items: center;
      width: 100%;
      height: 100vh;
      background-color: rgb(43, 41, 40);
      margin: 0;
      padding: 0;
      position: relative;
      z-index: 3;
    }

    .drop-container {
      width: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .spark-canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .invisible {
      display: none;
    }

    .canvas-container {
      position: fixed;
      inset: 0;
      background: rgb(56, 56, 62);
      z-index: 2;
    }

    .logo {
      position: absolute;
      top: clamp(4px, 1vw, 10px);
      left: clamp(4px, 1vw, 10px);
      z-index: 2;
      background: rgba(255, 255, 255, 0.2);
      padding: clamp(4px, 0.9vw, 6px) clamp(6px, 1.2vw, 8px);
      border-radius: clamp(8px, 1.4vw, 10px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
      backdrop-filter: blur(10px) saturate(140%);
      -webkit-backdrop-filter: blur(10px) saturate(140%);
      border: 1px solid rgba(255, 255, 255, 0.25);
    }

    .logo img {
      width: clamp(52px, 9vw, 80px);
      max-width: 24vw;
      height: auto;
      display: block;
    }

    .scene-title-overlay {
      position: absolute;
      top: clamp(4px, 1vw, 10px);
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
      max-width: min(70vw, 680px);
      padding: 6px 12px;
      border-radius: 10px;
      background: rgba(20, 20, 20, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.18);
      color: rgba(255, 255, 255, 0.94);
      font-size: clamp(0.75rem, 1.4vw, 0.9rem);
      line-height: 1.2;
      text-align: center;
      white-space: normal;
      overflow-wrap: anywhere;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.15s ease;
    }

    .scene-title-overlay.has-text {
      opacity: 1;
      visibility: visible;
    }

    .viewer-close-button {
      position: absolute;
      top: clamp(4px, 1vw, 10px);
      right: clamp(4px, 1vw, 10px);
      z-index: 2;
      width: clamp(28px, 3.2vw, 34px);
      height: clamp(28px, 3.2vw, 34px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      background: rgba(20, 20, 20, 0.58);
      color: rgba(255, 255, 255, 0.95);
      font-size: clamp(0.92rem, 2vw, 1.1rem);
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .viewer-close-button:hover {
      background: rgba(42, 42, 42, 0.75);
    }

    .hero-logo {
      text-align: center;
      margin-bottom: 2rem;
    }

    .hero-title {
      margin: 0 0 1.5rem 0;
      font-size: clamp(1.45rem, 2.8vw, 2.2rem);
      font-weight: 700;
      letter-spacing: 0.01em;
      color: rgba(255, 255, 255, 0.95);
      text-align: center;
      text-shadow: 0 4px 14px rgba(0, 0, 0, 0.35);
    }

    .hero-logo img {
      width: 350px;
      height: auto;
      margin-bottom: 1rem;
    }

    .url-select,
    .frame-limit-select,
    .drop-zone {
      width: 100%;
      max-width: 300px;
      margin: 0.5rem auto;
      padding: 0.75rem;
      border-radius: 6px;
      font-size: 0.7rem;
      text-align: center;
    }

    .drop-zone {
      max-width: 760px;
      padding-top: 4rem;
      padding-bottom: 4rem;
    }

    .url-select {
      background-color: rgb(47, 47, 47);
      border: none;
      color: #fff;
      text-align: center;
      cursor: pointer;
      font-family: system-ui, sans-serif;
      font-size: 0.7rem;
      font-weight: 400;
      appearance: none;
      -webkit-appearance: none;
      text-align-last: center;
      -moz-text-align-last: center;
      display: block;
    }

    .url-form {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .language-row {
      width: 100%;
      max-width: 760px;
      margin: 0.2rem auto 0.45rem auto;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 8px;
      padding: 0 4px;
      box-sizing: border-box;
    }

    .language-group {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
    }

    .language-label {
      font-size: 0.72rem;
      color: rgba(255, 255, 255, 0.8);
      font-weight: 500;
      white-space: nowrap;
    }

    .language-select {
      width: auto;
      min-width: 108px;
      max-width: 160px;
      margin: 0;
      padding: 0.45rem 0.65rem;
      font-size: 0.72rem;
      border-radius: 8px;
      text-align-last: center;
      -moz-text-align-last: center;
    }

    .url-row {
      width: 100%;
      max-width: 760px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin: 0.5rem auto;
    }

    .url-row .url-select,
    .url-row .frame-limit-wrap,
    .url-row .cache-all-button {
      width: 100%;
      max-width: none;
      margin: 0;
    }

    .scene-preview-grid {
      width: 100%;
      max-width: 760px;
      margin: 0.35rem auto 0.5rem auto;
      display: flex;
      flex-wrap: nowrap;
      gap: 10px;
      overflow-x: auto;
      overflow-y: hidden;
      padding-bottom: 4px;
      scroll-behavior: smooth;
    }

    .scene-preview-status {
      width: 100%;
      border-radius: 10px;
      border: 1px dashed rgba(255, 255, 255, 0.18);
      background: rgba(47, 47, 47, 0.78);
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.72rem;
      text-align: center;
      padding: 0.85rem 0.7rem;
    }

    .scene-card {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(47, 47, 47, 0.95);
      border-radius: 10px;
      padding: 8px;
      cursor: pointer;
      text-align: left;
      color: #fff;
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 0 0 180px;
      transition: border-color 0.15s ease, background-color 0.15s ease, transform 0.15s ease;
    }

    .scene-card:hover {
      background: rgb(58, 58, 58);
      border-color: rgba(255, 255, 255, 0.38);
      transform: translateY(-1px);
    }

    .scene-card.is-selected {
      border-color: rgba(122, 205, 152, 0.95);
      box-shadow: 0 0 0 1px rgba(122, 205, 152, 0.35) inset;
    }

    .scene-card.is-loading {
      opacity: 0.78;
      cursor: default;
    }

    .scene-card-thumb {
      width: 100%;
      aspect-ratio: 16 / 9;
      border-radius: 7px;
      overflow: hidden;
      background: rgb(35, 35, 35);
      border: 1px solid rgba(255, 255, 255, 0.12);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .scene-card-thumb img {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
    }

    .scene-card-thumb-fallback {
      font-size: 0.68rem;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 0.02em;
    }

    .scene-card-title {
      font-size: 0.74rem;
      line-height: 1.25;
      color: rgba(255, 255, 255, 0.92);
      text-align: center;
      word-break: break-word;
    }

    .frame-limit-wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      border-radius: 6px;
      background-color: rgb(47, 47, 47);
      color: #fff;
      font-family: system-ui, sans-serif;
      font-size: 0.7rem;
      font-weight: 400;
      overflow: hidden;
    }

    .frame-limit-select {
      background-color: transparent;
      border: none;
      color: #fff;
      font-family: system-ui, sans-serif;
      font-size: 0.7rem;
      font-weight: 400;
      display: block;
      width: 100%;
      text-align: center;
      text-align-last: center;
      -moz-text-align-last: center;
      padding: 0.75rem;
      margin: 0;
      outline: none;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
    }

    .cache-all-button {
      width: 100%;
      max-width: 760px;
      margin: 0.5rem auto 0.25rem auto;
      padding: 0.75rem;
      border: none;
      border-radius: 6px;
      background-color: rgb(60, 60, 60);
      color: #fff;
      font-size: 0.7rem;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    .url-row .cache-all-button {
      height: 100%;
      min-height: 42px;
      margin: 0;
      max-width: none;
      padding: 0.75rem 0.6rem;
      border-radius: 6px;
    }

    .cache-all-progress {
      position: absolute;
      inset: 0;
      width: 0%;
      background: rgba(255, 255, 255, 0.18);
      transition: width 0.18s ease;
      pointer-events: none;
    }

    .cache-all-button.is-caching .cache-all-progress {
      background-image: linear-gradient(
        120deg,
        rgba(255, 255, 255, 0.12) 0%,
        rgba(255, 255, 255, 0.28) 35%,
        rgba(255, 255, 255, 0.12) 70%
      );
      background-size: 200% 100%;
      animation: cacheProgressSweep 1s linear infinite;
    }

    @keyframes cacheProgressSweep {
      from {
        background-position: 200% 0;
      }
      to {
        background-position: 0 0;
      }
    }

    .cache-all-label {
      position: relative;
      z-index: 1;
    }

    .cache-all-label-text {
      display: inline;
    }

    .cache-all-label-dots {
      display: inline-block;
      width: 1.6em;
      text-align: left;
    }

    .cache-all-button:hover {
      background-color: rgb(90, 90, 90);
    }

    .cache-all-button:disabled {
      opacity: 0.7;
      cursor: default;
    }

    .drop-zone {
      border: 1px dashed #666;
      color: rgb(89, 89, 89);
      background-color: rgb(47, 47, 47);
      cursor: pointer;
    }

    .drop-zone.dragover {
      border: 1px dashed #aaa;
      color: rgb(170, 170, 170);
    }

    @media (min-width: 600px) {
      .url-select,
      .frame-limit-wrap,
      .frame-limit-select,
      .drop-zone {
        font-size: 0.77rem;
      }

      .cache-all-button {
        font-size: 0.77rem;
      }
    }

    .hidden {
      display: none;
    }

    .controls {
      position: relative;
      display: grid;
      grid-template-columns: auto minmax(0, 1fr) auto;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background: rgba(28, 28, 28, 0.7);
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(8px);
      z-index: 2;
      width: 100%;
      pointer-events: auto;
    }

    .controls .controls-left,
    .controls .controls-right {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .controls .controls-right {
      min-width: 0;
      flex-wrap: wrap;
      justify-content: flex-end;
      row-gap: 8px;
    }

    .controls .controls-right > * {
      flex-shrink: 0;
    }

    .controls .play-toggle {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1em;
      background: rgba(255, 255, 255, 0.15);
    }

    .controls .caching-percent {
      display: none;
      min-width: 44px;
      font-size: 0.8em;
      color: rgba(255, 255, 255, 0.8);
      font-variant-numeric: tabular-nums;
      text-align: left;
    }

    .controls .caching-percent.is-visible {
      display: inline-block;
    }

    .controls .play-toggle.is-loading {
      cursor: default;
      opacity: 0.7;
    }

    .controls .play-toggle .loading-spinner {
      display: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.4);
      border-top-color: #fff;
      animation: spin 0.9s linear infinite;
    }

    .controls .play-toggle.is-loading .play-icon {
      display: none;
    }

    .controls .play-toggle.is-loading .loading-spinner {
      display: inline-block;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .controls .play-toggle .play-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      position: relative;
      color: transparent;
      font-size: 0;
      line-height: 0;
    }

    .controls .play-toggle .play-icon::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-42%, -50%);
      width: 0;
      height: 0;
      border-top: 6px solid transparent;
      border-bottom: 6px solid transparent;
      border-left: 10px solid #fff;
    }

    .controls .play-toggle.is-playing .play-icon::before,
    .controls .play-toggle.is-playing .play-icon::after {
      content: '';
      position: absolute;
      top: 50%;
      width: 4px;
      height: 12px;
      border-radius: 1px;
      background: #fff;
      transform: translateY(-50%);
    }

    .controls .play-toggle.is-playing .play-icon::before {
      left: 4px;
      border: none;
    }

    .controls .play-toggle.is-playing .play-icon::after {
      right: 4px;
    }

    .controls .progress-wrap {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 8px;
      width: 100%;
      min-width: 0;
    }

    .controls .fov-wrap {
      display: none;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.08);
    }

    .controls .fov-label {
      font-size: 0.8em;
      color: rgba(255, 255, 255, 0.7);
      white-space: nowrap;
    }

    .controls .fov-value {
      min-width: 38px;
      text-align: right;
      font-variant-numeric: tabular-nums;
      color: rgba(255, 255, 255, 0.85);
      font-size: 0.85em;
    }

    .controls .fov-slider {
      width: 90px;
      accent-color: #fff;
    }

    .controls .time {
      font-size: 0.82em;
      color: rgba(255, 255, 255, 0.7);
      min-width: 44px;
      text-align: center;
    }

    .controls .progress {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.15);
      outline: none;
    }

    .controls .progress::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.15);
      cursor: pointer;
    }

    .controls .progress::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #fff;
      border: none;
      cursor: pointer;
    }

    .viewer-window {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      pointer-events: none;
      --viewer-window-padding: clamp(12px, 2vw, 28px);
      padding: var(--viewer-window-padding);
    }

    .viewer-window .viewer-stack {
      width: min(92vw, 1220px, calc(min(86dvh, 760px) * 16 / 9));
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      margin: auto;
      max-height: calc(100dvh - (var(--viewer-window-padding) * 2));
      pointer-events: auto;
    }

    .viewer-window .window-frame {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      height: auto;
      background: #111;
      border: 3px solid rgba(180, 180, 180, 0.75);
      border-radius: clamp(16px, 2.2vw, 28px);
      overflow: hidden;
      box-shadow: 0 30px 80px rgba(0, 0, 0, 0.55);
      pointer-events: auto;
    }

    .viewer-preview-overlay {
      position: absolute;
      inset: 0;
      z-index: 1;
      display: none;
      pointer-events: none;
      background: rgb(17, 17, 17);
    }

    .viewer-preview-overlay.is-visible {
      display: block;
    }

    .viewer-preview-overlay img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .controls-right #VRButton {
      position: static !important;
      left: auto !important;
      bottom: auto !important;
      width: auto !important;
      min-width: 80px;
      padding: 0 6px !important;
      border: none !important;
      border-radius: 10px !important;
      background-color: rgba(255, 255, 255, 0.12) !important;
      opacity: 1 !important;
      font-size: 0 !important;
      line-height: 1;
      height: 30px !important;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-shadow: none !important;
      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;
    }

    .controls-right #VRButton:hover {
      background-color: rgb(90, 90, 90) !important;
    }

    .controls-right #VRButton::before {
      content: 'VR';
      font-size: 0.95rem;
      font-weight: 600;
      line-height: 1;
      letter-spacing: 0.02em;
    }

    .controls button {
      background-color: rgba(255, 255, 255, 0.12);
      border: none;
      color: #fff;
      padding: 6px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9em;
    }

    .controls button:hover {
      background-color: rgb(90, 90, 90);
    }

    .controls select {
      background: rgba(255, 255, 255, 0.12);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 0.85em;
      cursor: pointer;
    }

    .controls .controls-right > .speed-select,
    .controls .controls-right > .import-button,
    .controls .controls-right > .reset-button,
    .controls .controls-right > #VRButton {
      min-width: 80px;
      height: 30px;
      padding: 0 6px;
      border-radius: 10px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      text-align: center;
      font-size: 0.74em;
    }

    .controls .controls-right > .speed-select {
      width: 80px;
      text-align: center;
      text-align-last: center;
      -moz-text-align-last: center;
    }

    .frame-indicator {
      font-size: 0.85em;
      color: rgba(255, 255, 255, 0.65);
      padding: 0 6px;
      white-space: nowrap;
    }

    .frame-indicator-progress {
      display: none;
      min-width: 52px;
      text-align: right;
      padding-right: 0;
    }

    @media (orientation: landscape) and (max-height: 520px) {
      .viewer-window {
        --viewer-window-padding: clamp(6px, 1.2vh, 10px);
      }

      .viewer-window .viewer-stack {
        width: min(96vw, 1220px, calc((100dvh - (var(--viewer-window-padding) * 2) - 72px) * 16 / 9));
        gap: 8px;
      }

      .controls {
        padding: 6px 8px;
        gap: 6px;
      }
    }

    @media (max-width: 1100px) {
      .controls {
        grid-template-columns: auto minmax(0, 1fr);
        grid-template-areas:
          'left progress'
          'right right';
        gap: 8px 10px;
        padding: 8px 10px;
      }

      .controls .controls-left {
        grid-area: left;
      }

      .controls .progress-wrap {
        grid-area: progress;
      }

      .controls .controls-right {
        grid-area: right;
      }

      .controls .controls-left {
        justify-self: start;
      }

      .controls .controls-right {
        width: 100%;
        flex-wrap: wrap;
        justify-content: space-evenly;
        gap: 10px 12px;
      }

      .controls .progress-wrap {
        width: 100%;
        min-width: 0;
        grid-template-columns: auto minmax(0, 1fr) auto auto;
      }

      .controls .frame-indicator-progress {
        display: inline-block;
        font-size: 0.82em;
      }

      .controls .frame-indicator-actions {
        display: none;
      }

      .controls .time {
        min-width: 54px;
      }

      .controls .fov-slider {
        width: min(120px, 22vw);
      }
    }

    @media (max-width: 760px) {
      .drop-container {
        padding-left: 12px;
        padding-right: 12px;
      }

      .url-row,
      .language-row,
      .scene-preview-grid,
      .cache-all-button,
      .drop-zone {
        max-width: 100%;
      }

      .scene-card {
        flex-basis: 168px;
      }

      .language-row {
        gap: 8px;
        padding: 0 2px;
        justify-content: flex-end;
      }

      .language-group {
        gap: 6px;
      }

      .language-select {
        min-width: 92px;
        padding: 0.4rem 0.55rem;
      }

      .controls {
        grid-template-columns: auto minmax(0, 1fr) auto;
        grid-template-areas: 'left progress right';
        border-radius: 12px;
        padding: 8px;
        gap: 6px;
        overflow-x: auto;
      }

      .controls .controls-left {
        grid-area: left;
        justify-content: flex-start;
      }

      .controls .play-toggle {
        width: 36px;
        height: 36px;
      }

      .controls .controls-right {
        grid-area: right;
        width: auto;
        display: flex;
        flex-wrap: nowrap;
        justify-content: flex-end;
        gap: 6px;
      }

      .controls button,
      .controls select {
        font-size: 0.82em;
        padding: 5px 10px;
      }

      .controls .controls-right > .speed-select,
      .controls .controls-right > .import-button,
      .controls .controls-right > .reset-button,
      .controls .controls-right > #VRButton {
        flex: 0 0 auto;
        min-width: 64px;
        width: auto;
        height: 28px;
        padding: 0 6px;
      }

      .controls .controls-right > #VRButton {
        min-width: 64px !important;
        width: auto !important;
        height: 28px !important;
        padding: 0 6px !important;
      }

      .controls .progress-wrap {
        grid-template-columns: max-content minmax(0, 1fr) max-content max-content;
        gap: 4px;
      }

      .controls .frame-indicator-progress {
        min-width: 0;
        padding: 0;
        font-size: 0.74em;
      }

      .controls .fov-wrap {
        flex: 1 1 100%;
        justify-content: center;
        gap: 6px;
        padding: 4px 6px;
      }

      .controls .fov-slider {
        width: min(140px, 42vw);
      }

      .controls .time {
        min-width: 0;
        font-size: 0.76em;
      }

      .scene-title-overlay {
        max-width: calc(100% - 128px);
        padding: 5px 9px;
        font-size: 0.74rem;
      }

      .logo {
        transform: scale(0.7);
        transform-origin: top left;
      }

      .scene-title-overlay {
        transform: translateX(-50%) scale(0.7);
        transform-origin: top center;
      }

      .viewer-close-button {
        transform: scale(0.7);
        transform-origin: top right;
      }
    }

    @media (orientation: landscape) and (max-height: 520px) and (max-width: 900px) {
      .controls {
        grid-template-columns: auto minmax(0, 1fr) auto;
        grid-template-areas: 'left progress right';
        align-items: center;
      }

      .controls .controls-left {
        grid-area: left;
      }

      .controls .progress-wrap {
        grid-area: progress;
      }

      .controls .controls-right {
        grid-area: right;
        width: auto;
        flex-wrap: nowrap;
        justify-content: flex-end;
        gap: 6px;
      }

      .controls .controls-right > .speed-select,
      .controls .controls-right > .import-button,
      .controls .controls-right > .reset-button,
      .controls .controls-right > #VRButton {
        flex: 0 0 auto;
        width: auto;
        min-width: 68px;
      }

      .controls .controls-right > #VRButton {
        width: auto !important;
        min-width: 68px !important;
      }
    }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "./vendor/three/build/three.module.js",
        "three/addons/": "./vendor/three/examples/jsm/",
        "@sparkjsdev/spark": "./dist/spark.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from "three";
    import { SplatMesh, SparkControls, SparkRenderer, VRButton } from "@sparkjsdev/spark";

    const LANG_STORAGE_KEY = 'pico-ui-language';

    function normalizeLanguageCode(raw) {
      const value = String(raw || '').trim().toLowerCase();
      if (value.startsWith('zh')) return 'zh';
      if (value.startsWith('en')) return 'en';
      return '';
    }

    function resolveUiLanguage() {
      const urlLang = normalizeLanguageCode(new URLSearchParams(window.location.search).get('lang'));
      if (urlLang) return urlLang;
      try {
        const stored = normalizeLanguageCode(localStorage.getItem(LANG_STORAGE_KEY));
        if (stored) return stored;
      } catch {
      }
      const browserLang = normalizeLanguageCode(navigator.language || navigator.userLanguage || 'en');
      return browserLang || 'en';
    }

    const UI_LANG = resolveUiLanguage();
    document.documentElement.lang = UI_LANG === 'zh' ? 'zh-CN' : 'en';

    const I18N_TEXT = {
      en: {
        heroTitle: 'PICO 6DoF Player',
        dragDrop: 'Drag and drop splat (.ply, .sog, .spz, .splat, .ksplat) here',
        folderList: 'Folder list',
        frameRange: 'Frame range',
        selectFolder: 'Select folder...',
        shortFrames: 'Short (16 Frames)',
        mediumFrames: 'Medium (32 Frames)',
        longFrames: 'Long (All Frames)',
        import: 'Import',
        reset: 'Recenter',
        spatialOn: 'Spatial On',
        spatialOff: 'Spatial Off',
        play: 'Play',
        pause: 'Pause',
        enterVr: 'Enter VR',
        exitVr: 'Exit VR',
        loadingFolders: 'Loading folders...',
        folderUnavailable: 'Folder list unavailable',
        noFolders: 'No folders',
        loadingScenePreviews: 'Loading scene previews...',
        scenePreviewsUnavailable: 'Scene previews unavailable',
        noScenePreviews: 'No scene previews found',
        noPreview: 'No preview',
        cache: 'Cache All',
        noScenesFound: 'No scenes found',
        cachingProgress: 'Caching {done}/{total}',
        cachedProgress: 'Cached {done}/{total}',
        noSplatFilesAtUrl: 'No .ply / .spz / .splat / .ksplat / .sog files found at that URL',
        failedToLoadScene: 'Failed to load scene: {message}',
        language: 'Language',
        langZh: '中文',
        langEn: 'English',
        importedFiles: 'Imported Files',
        motionOff: 'Motion Off',
        motionOn: 'Motion On',
        motionUnsupported: 'No Motion Sensor',
        motionDenied: 'Motion Denied',
        enableMotion: 'Enable motion control',
        disableMotion: 'Disable motion control',
      },
      zh: {
        heroTitle: 'PICO 6DoF 播放器',
        dragDrop: '将 splat (.ply, .sog, .spz, .splat, .ksplat) 拖拽到这里',
        folderList: '场景列表',
        frameRange: '帧范围',
        selectFolder: '选择场景...',
        shortFrames: '短（16 帧）',
        mediumFrames: '中（32 帧）',
        longFrames: '长（全部帧）',
        import: '导入',
        reset: '回中',
        spatialOn: '空间开',
        spatialOff: '空间关',
        play: '播放',
        pause: '暂停',
        enterVr: '进入 VR',
        exitVr: '退出 VR',
        loadingFolders: '正在加载场景...',
        folderUnavailable: '场景列表不可用',
        noFolders: '暂无场景',
        loadingScenePreviews: '正在加载预览...',
        scenePreviewsUnavailable: '场景预览不可用',
        noScenePreviews: '暂无场景预览',
        noPreview: '暂无预览',
        cache: '缓存所有',
        noScenesFound: '未找到场景',
        cachingProgress: '缓存中 {done}/{total}',
        cachedProgress: '已缓存 {done}/{total}',
        noSplatFilesAtUrl: '该地址未找到 .ply / .spz / .splat / .ksplat / .sog 文件',
        failedToLoadScene: '场景加载失败：{message}',
        language: '语言',
        langZh: '中文',
        langEn: 'English',
        importedFiles: '本地文件',
        motionOff: '体感关',
        motionOn: '体感开',
        motionUnsupported: '无体感传感器',
        motionDenied: '体感被拒绝',
        enableMotion: '启用体感控制',
        disableMotion: '关闭体感控制',
      },
    };

    const SCENE_NAME_I18N = {
      '仓大佬跳舞': { zh: '仓大佬跳舞', en: 'Cang Dance' },
      '动物世界': { zh: '动物世界', en: 'Animal World' },
      '少年派': { zh: '少年派', en: 'Life of Pi' },
      '直播美女': { zh: '直播美女', en: 'Live Beauty' },
    };

    function t(key, vars = {}) {
      const table = I18N_TEXT[UI_LANG] || I18N_TEXT.en;
      const fallback = I18N_TEXT.en;
      const template = table[key] ?? fallback[key] ?? key;
      return String(template).replace(/\{(\w+)\}/g, (_, token) => {
        if (Object.prototype.hasOwnProperty.call(vars, token)) {
          return String(vars[token]);
        }
        return `{${token}}`;
      });
    }

    function localizeSceneName(rawName) {
      const key = String(rawName || '').trim();
      if (!key) return '';
      const entry = SCENE_NAME_I18N[key];
      if (!entry) return key;
      return entry[UI_LANG] || entry.en || key;
    }

    function applyStaticI18n() {
      const textEls = document.querySelectorAll('[data-i18n-key]');
      textEls.forEach((el) => {
        const key = el.dataset.i18nKey;
        if (!key) return;
        el.textContent = t(key);
      });

      const ariaEls = document.querySelectorAll('[data-i18n-aria-label]');
      ariaEls.forEach((el) => {
        const key = el.dataset.i18nAriaLabel;
        if (!key) return;
        el.setAttribute('aria-label', t(key));
      });

      const titleEls = document.querySelectorAll('[data-i18n-title]');
      titleEls.forEach((el) => {
        const key = el.dataset.i18nTitle;
        if (!key) return;
        el.setAttribute('title', t(key));
      });
    }

    const sparkCanvasEl = document.querySelector(".spark-canvas");
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.set(0, 0, 0);
    const renderer = new THREE.WebGLRenderer({canvas: sparkCanvasEl});
    const frameEl = document.querySelector('.window-frame');
    const width = frameEl.clientWidth;
    const height = frameEl.clientHeight;
    renderer.setSize(width, height, false);

    // VR mode support
    const localFrame = new THREE.Group();
    scene.add(localFrame);

    const spark = new SparkRenderer({ renderer, maxStdDev: Math.sqrt(5) });
    localFrame.add(spark);
    scene.add(camera);

    const vrButton = VRButton.createButton(renderer, {
      optionalFeatures: ["hand-tracking"],
    });

    const DEFAULT_WIN_W = 2.112, DEFAULT_WIN_H = 1.188;   // window opening in world meters (+10%)
    let winW = DEFAULT_WIN_W;
    let winH = DEFAULT_WIN_H;
    const VR_TARGET_VISIBLE_AREA = 0.8;
    const VR_TARGET_VISIBLE_AXIS = Math.sqrt(VR_TARGET_VISIBLE_AREA);
    const VR_MIN_WIN_W = 0.9;
    const VR_MAX_WIN_W = 3.0;
    const VR_MIN_WIN_H = 0.5;
    const VR_MAX_WIN_H = 1.8;
    // ── VR Window Frame (mask) ──
    // A large dark-gray plane with a transparent rounded-rect hole in the center.
    // Outside the hole = opaque dark matte (blocks rear texture), inside the hole = transparent (shows 3DGS).
    const MASK_CANVAS_W = 3200, MASK_CANVAS_H = 2000;
    const MASK_PLANE_W = 10.0, MASK_PLANE_H = 6.25;  // plane world size (matches canvas aspect 1600:1000)

    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = MASK_CANVAS_W;
    maskCanvas.height = MASK_CANVAS_H;
    const maskCtx = maskCanvas.getContext('2d');

    const maskTexture = new THREE.CanvasTexture(maskCanvas);
    maskTexture.minFilter = THREE.LinearFilter;
    maskTexture.magFilter = THREE.LinearFilter;
    maskTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    maskTexture.generateMipmaps = false;
    const maskMaterial = new THREE.MeshBasicMaterial({
      map: maskTexture,
      transparent: true,
      side: THREE.DoubleSide,
      depthTest: false,
      depthWrite: false,
    });
    const vrWindowMask = new THREE.Mesh(
      new THREE.PlaneGeometry(MASK_PLANE_W, MASK_PLANE_H),
      maskMaterial,
    );
    vrWindowMask.renderOrder = 9998;
    vrWindowMask.frustumCulled = false;
    vrWindowMask.visible = false;

    // Container group for the window
    const vrFrameGroup = new THREE.Group();
    vrFrameGroup.visible = false;
    scene.add(vrFrameGroup);

    const vrBounds = new THREE.Box3();
    const vrSplatCenterWorld = new THREE.Vector3();
    const vrSplatCenterInFrame = new THREE.Vector3();
    const vrFrameRight = new THREE.Vector3();
    const vrFrameUp = new THREE.Vector3();
    const vrCorner = new THREE.Vector3();

    const FRAME_DIST = 2.0;
    vrWindowMask.position.set(0, 0, -FRAME_DIST);
    vrFrameGroup.add(vrWindowMask);

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    function drawVrWindowMask(openW, openH) {
      winW = Math.max(VR_MIN_WIN_W, Math.min(VR_MAX_WIN_W, Number(openW) || DEFAULT_WIN_W));
      winH = Math.max(VR_MIN_WIN_H, Math.min(VR_MAX_WIN_H, Number(openH) || DEFAULT_WIN_H));

      const holePixW = (winW / MASK_PLANE_W) * MASK_CANVAS_W;
      const holePixH = (winH / MASK_PLANE_H) * MASK_CANVAS_H;
      const holeX = (MASK_CANVAS_W - holePixW) / 2;
      const holeY = (MASK_CANVAS_H - holePixH) / 2;
      const holeRad = Math.max(20, Math.min(120, Math.min(holePixW, holePixH) * 0.12));

      // 1) Fill canvas with opaque dark matte to fully block rear texture bleed in VR
      maskCtx.clearRect(0, 0, MASK_CANVAS_W, MASK_CANVAS_H);
      maskCtx.fillStyle = 'rgba(16, 16, 18, 1)';
      maskCtx.fillRect(0, 0, MASK_CANVAS_W, MASK_CANVAS_H);

      // 2) Cut out a transparent rounded-rect hole in the center
      maskCtx.globalCompositeOperation = 'destination-out';
      maskCtx.fillStyle = '#000';
      roundRect(maskCtx, holeX, holeY, holePixW, holePixH, holeRad);
      maskCtx.fill();
      maskCtx.globalCompositeOperation = 'source-over';

      // 3) Draw a subtle border around the window opening
      maskCtx.strokeStyle = 'rgba(180, 180, 180, 0.6)';
      maskCtx.lineWidth = 3 * (MASK_CANVAS_W / 1600);
      roundRect(maskCtx, holeX, holeY, holePixW, holePixH, holeRad);
      maskCtx.stroke();

      // 4) Outer shadow / vignette around the hole
      maskCtx.shadowColor = 'rgba(0, 0, 0, 0.3)';
      maskCtx.shadowBlur = 30 * (MASK_CANVAS_W / 1600);
      maskCtx.strokeStyle = 'rgba(0,0,0,0)';
      maskCtx.lineWidth = 1;
      roundRect(maskCtx, holeX - 1, holeY - 1, holePixW + 2, holePixH + 2, holeRad);
      maskCtx.stroke();
      maskCtx.shadowBlur = 0;

      maskTexture.needsUpdate = true;

    }

    drawVrWindowMask(DEFAULT_WIN_W, DEFAULT_WIN_H);

    function centerSplatInVrWindow() {
      if (!loadedSplat) return;
      vrBounds.setFromObject(loadedSplat);
      if (vrBounds.isEmpty()) return;

      vrBounds.getCenter(vrSplatCenterWorld);
      vrSplatCenterInFrame.copy(vrSplatCenterWorld);
      vrFrameGroup.worldToLocal(vrSplatCenterInFrame);

      const dx = vrSplatCenterInFrame.x;
      const dy = vrSplatCenterInFrame.y;
      if (Math.abs(dx) + Math.abs(dy) < 1e-6) return;

      vrFrameRight.set(1, 0, 0).applyQuaternion(vrFrameGroup.quaternion);
      vrFrameUp.set(0, 1, 0).applyQuaternion(vrFrameGroup.quaternion);
      localFrame.position.addScaledVector(vrFrameRight, -dx);
      localFrame.position.addScaledVector(vrFrameUp, -dy);
    }

    function fitVrWindowToSplat() {
      if (!loadedSplat) {
        drawVrWindowMask(DEFAULT_WIN_W, DEFAULT_WIN_H);
        return;
      }

      centerSplatInVrWindow();

      vrBounds.setFromObject(loadedSplat);
      if (vrBounds.isEmpty()) {
        drawVrWindowMask(DEFAULT_WIN_W, DEFAULT_WIN_H);
        return;
      }

      const xs = [vrBounds.min.x, vrBounds.max.x];
      const ys = [vrBounds.min.y, vrBounds.max.y];
      const zs = [vrBounds.min.z, vrBounds.max.z];

      let minX = Number.POSITIVE_INFINITY;
      let maxX = Number.NEGATIVE_INFINITY;
      let minY = Number.POSITIVE_INFINITY;
      let maxY = Number.NEGATIVE_INFINITY;

      for (const x of xs) {
        for (const y of ys) {
          for (const z of zs) {
            vrCorner.set(x, y, z);
            vrFrameGroup.worldToLocal(vrCorner);
            minX = Math.min(minX, vrCorner.x);
            maxX = Math.max(maxX, vrCorner.x);
            minY = Math.min(minY, vrCorner.y);
            maxY = Math.max(maxY, vrCorner.y);
          }
        }
      }

      const spanX = Math.max(1e-4, maxX - minX);
      const spanY = Math.max(1e-4, maxY - minY);
      const desiredW = spanX * VR_TARGET_VISIBLE_AXIS;
      const desiredH = spanY * VR_TARGET_VISIBLE_AXIS;
      drawVrWindowMask(desiredW, desiredH);

      // Recenter once more after changing aperture size.
      centerSplatInVrWindow();
    }

    let shouldResetViewAfterVrExit = false;
    let vrFrameInitialized = false;
    let pendingVrRefit = false;
    let xrPlaybackClockInitialized = false;
    let xrPlaybackLastTimestamp = 0;
    let xrPlaybackElapsedMs = 0;

    function resetXrPlaybackClock() {
      xrPlaybackClockInitialized = false;
      xrPlaybackLastTimestamp = 0;
      xrPlaybackElapsedMs = 0;
    }

    renderer.xr.addEventListener('sessionstart', () => {
      if (vrButton) {
        vrButton.setAttribute('aria-label', t('exitVr'));
        vrButton.setAttribute('title', t('exitVr'));
      }
      vrFrameGroup.visible = true;
      vrWindowMask.visible = true;
      vrFrameInitialized = false;
      vrFrameGroup.position.set(0, 0, 0);
      vrFrameGroup.rotation.set(0, 0, 0);
      localFrame.position.set(0, 0, 0);
      localFrame.rotation.set(0, 0, 0);
      localFrame.scale.set(1, 1, 1);
      drawVrWindowMask(DEFAULT_WIN_W, DEFAULT_WIN_H);
      pendingVrRefit = true;
      stopPlayback();
      resetXrPlaybackClock();
    });
    renderer.xr.addEventListener('sessionend', () => {
      if (vrButton) {
        vrButton.setAttribute('aria-label', t('enterVr'));
        vrButton.setAttribute('title', t('enterVr'));
      }
      vrFrameGroup.visible = false;
      vrWindowMask.visible = false;
      localFrame.position.set(0, 0, 0);
      localFrame.rotation.set(0, 0, 0);
      localFrame.scale.set(1, 1, 1);
      vrFrameInitialized = false;
      pendingVrRefit = false;
      resetXrPlaybackClock();
      if (isPlaying) {
        scheduleNextPlaybackTick();
      }
      resetViewState();
      shouldResetViewAfterVrExit = true;
    });

    const controls = new SparkControls({ canvas: sparkCanvasEl });
    controls.fpsMovement.rotateSpeed = 0.6;
    controls.fpsMovement.moveSpeed = 0.8;
    controls.fpsMovement.keycodeMoveMapping = {
      KeyW: new THREE.Vector3(0, 0, -1),
      KeyS: new THREE.Vector3(0, 0, 1),
      KeyA: new THREE.Vector3(-1, 0, 0),
      KeyD: new THREE.Vector3(1, 0, 0),
      KeyR: new THREE.Vector3(0, 1, 0),
      KeyF: new THREE.Vector3(0, -1, 0),
    };
    controls.fpsMovement.keycodeRotateMapping = {};

    const IS_TOUCH_DEVICE = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
    const IS_MOBILE_DEVICE = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
      || (IS_TOUCH_DEVICE && Math.min(window.screen.width, window.screen.height) <= 1024);
    const motionParams = new URLSearchParams(window.location.search);
    const motionMoveAngleParam = Number(motionParams.get('motionMoveAngle'));
    const motionRotateDeadzoneParam = Number(motionParams.get('motionRotateDeadzone'));
    const MOBILE_MOTION_ROTATE_DEADZONE_DEG = THREE.MathUtils.clamp(
      Number.isFinite(motionRotateDeadzoneParam) ? motionRotateDeadzoneParam : 4,
      1,
      12,
    );
    const MOBILE_MOTION_ROTATE_ABS_MAX_DEG = 5;
    const MOBILE_MOTION_ROTATE_RANGE_DEG = MOBILE_MOTION_ROTATE_ABS_MAX_DEG;
    const MOBILE_MOTION_ROTATE_MAX_DEG = MOBILE_MOTION_ROTATE_ABS_MAX_DEG;
    const MOBILE_MOTION_MOVE_START_DEG = THREE.MathUtils.clamp(
      Number.isFinite(motionMoveAngleParam) ? motionMoveAngleParam : 2,
      0.5,
      MOBILE_MOTION_ROTATE_ABS_MAX_DEG - 0.5,
    );
    const MOBILE_MOTION_MOVE_MAX_DEG = MOBILE_MOTION_ROTATE_ABS_MAX_DEG;
    const MOBILE_MOTION_MOVE_MAX_DISTANCE_FORWARD = 0.3;
    const MOBILE_MOTION_MOVE_MAX_DISTANCE_BACKWARD = 0.1;
    const MOBILE_MOTION_RECENTER_RATE = 2.2;
    const MOBILE_MOTION_REST_ANGLE_DEG = 6;
    const MOBILE_MOTION_EVENT_TIMEOUT_MS = 450;

    const motionForwardVector = new THREE.Vector3();
    const motionState = {
      supported: typeof window.DeviceOrientationEvent !== 'undefined',
      enabled: false,
      listenersBound: false,
      permissionDenied: false,
      baselineBeta: null,
      baselineGamma: null,
      filteredBetaDelta: 0,
      filteredGammaDelta: 0,
      lastBeta: null,
      lastGamma: null,
      lastEventTimeMs: 0,
      anchorReady: false,
      anchorOrbitYaw: 0,
      anchorOrbitPitch: 0,
      anchorOrbitDistance: 1.5,
      anchorOrbitTarget: new THREE.Vector3(),
      anchorForward: new THREE.Vector3(0, 0, -1),
    };

    const orbitTarget = new THREE.Vector3(0, 0, 0);
    let orbitYaw = 0;
    let orbitPitch = 0;
    let orbitDistance = 1.5;
    const orbitSpeed = 0.005;
    const lastCameraPos = new THREE.Vector3().copy(camera.position);
    let initialOrbitTarget = new THREE.Vector3(0, 0, 0);
    let initialOrbitYaw = 0;
    let initialOrbitPitch = 0;
    let initialOrbitDistance = 1.5;
    let hasInitialOrbit = false;
    const orbitKeyState = {
      ArrowLeft: false,
      ArrowRight: false,
      ArrowUp: false,
      ArrowDown: false,
    };

    function wrapSignedDeltaDegrees(value) {
      const normalized = ((value + 180) % 360 + 360) % 360 - 180;
      return normalized;
    }

    function resetMotionBaseline() {
      motionState.baselineBeta = null;
      motionState.baselineGamma = null;
      motionState.filteredBetaDelta = 0;
      motionState.filteredGammaDelta = 0;
      motionState.lastBeta = null;
      motionState.lastGamma = null;
      motionState.lastEventTimeMs = 0;
    }

    function resetMotionAnchor() {
      motionState.anchorReady = false;
    }

    function captureMotionAnchorFromCurrentCamera() {
      syncOrbitFromCamera();
      motionState.anchorOrbitYaw = orbitYaw;
      motionState.anchorOrbitPitch = orbitPitch;
      motionState.anchorOrbitDistance = orbitDistance;
      motionState.anchorOrbitTarget.copy(orbitTarget);
      camera.getWorldDirection(motionState.anchorForward);
      motionState.anchorForward.y = 0;
      if (motionState.anchorForward.lengthSq() <= 1e-6) {
        motionState.anchorForward.set(0, 0, -1);
      } else {
        motionState.anchorForward.normalize();
      }
      motionState.anchorReady = true;
    }

    function applyDeadzoneAndNormalize(value, deadzoneDeg, maxRangeDeg) {
      const absValue = Math.abs(value);
      if (absValue <= deadzoneDeg) return 0;
      const normalized = (absValue - deadzoneDeg) / Math.max(1, maxRangeDeg - deadzoneDeg);
      return Math.sign(value) * THREE.MathUtils.clamp(normalized, 0, 1);
    }

    function handleDeviceOrientation(event) {
      if (!motionState.enabled) return;
      const { beta, gamma } = event;
      if (!Number.isFinite(beta) || !Number.isFinite(gamma)) return;

      motionState.lastBeta = beta;
      motionState.lastGamma = gamma;
      motionState.lastEventTimeMs = performance.now();

      if (motionState.baselineBeta == null || motionState.baselineGamma == null) {
        motionState.baselineBeta = beta;
        motionState.baselineGamma = gamma;
        return;
      }

      const betaDelta = THREE.MathUtils.clamp(
        wrapSignedDeltaDegrees(beta - motionState.baselineBeta),
        -60,
        60,
      );
      const gammaDelta = THREE.MathUtils.clamp(
        wrapSignedDeltaDegrees(gamma - motionState.baselineGamma),
        -60,
        60,
      );

      const smoothFactor = 0.18;
      motionState.filteredBetaDelta += (betaDelta - motionState.filteredBetaDelta) * smoothFactor;
      motionState.filteredGammaDelta += (gammaDelta - motionState.filteredGammaDelta) * smoothFactor;
    }

    function applyMotionAutoRecenter(deltaSeconds) {
      if (!motionState.enabled) return;
      if (!Number.isFinite(motionState.lastBeta) || !Number.isFinite(motionState.lastGamma)) return;
      if (!Number.isFinite(motionState.baselineBeta) || !Number.isFinite(motionState.baselineGamma)) return;

      const nowMs = performance.now();
      if (nowMs - motionState.lastEventTimeMs > MOBILE_MOTION_EVENT_TIMEOUT_MS) {
        motionState.filteredBetaDelta *= 0.8;
        motionState.filteredGammaDelta *= 0.8;
        return;
      }

      const betaDelta = THREE.MathUtils.clamp(
        wrapSignedDeltaDegrees(motionState.lastBeta - motionState.baselineBeta),
        -60,
        60,
      );
      const gammaDelta = THREE.MathUtils.clamp(
        wrapSignedDeltaDegrees(motionState.lastGamma - motionState.baselineGamma),
        -60,
        60,
      );

      const seemsStill = Math.abs(betaDelta) < MOBILE_MOTION_REST_ANGLE_DEG
        && Math.abs(gammaDelta) < MOBILE_MOTION_REST_ANGLE_DEG;
      const hasIntent = Math.abs(betaDelta) >= MOBILE_MOTION_MOVE_START_DEG
        || Math.abs(gammaDelta) >= MOBILE_MOTION_ROTATE_DEADZONE_DEG + 3;

      if (seemsStill && !hasIntent) {
        const adapt = THREE.MathUtils.clamp(MOBILE_MOTION_RECENTER_RATE * deltaSeconds, 0, 0.5);
        motionState.baselineBeta += betaDelta * adapt;
        motionState.baselineGamma += gammaDelta * adapt;
      }
    }

    function bindMotionListeners() {
      if (motionState.listenersBound) return;
      window.addEventListener('deviceorientation', handleDeviceOrientation, true);
      window.addEventListener('orientationchange', () => {
        resetMotionBaseline();
      });
      motionState.listenersBound = true;
    }

    function setMotionEnabled(enabled) {
      const nextEnabled = Boolean(enabled && motionState.supported);
      motionState.enabled = nextEnabled;
      if (nextEnabled) {
        bindMotionListeners();
        resetMotionBaseline();
        resetMotionAnchor();
      } else {
        resetMotionBaseline();
        resetMotionAnchor();
      }
    }

    async function requestMotionPermissionIfNeeded() {
      if (!motionState.supported) return false;

      const pending = [];
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        pending.push(DeviceOrientationEvent.requestPermission());
      }
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        pending.push(DeviceMotionEvent.requestPermission());
      }
      if (!pending.length) return true;

      const results = await Promise.allSettled(pending);
      return results.every((entry) => entry.status === 'fulfilled' && entry.value === 'granted');
    }

    function applyMobileMotionInput(deltaSeconds) {
      if (!motionState.enabled || deltaSeconds <= 0) {
        return { rotated: false, moved: false };
      }

      if (!motionState.anchorReady) {
        captureMotionAnchorFromCurrentCamera();
      }

      applyMotionAutoRecenter(deltaSeconds);

      let rotated = false;
      let moved = false;

      const yawInput = applyDeadzoneAndNormalize(
        THREE.MathUtils.clamp(
          motionState.filteredGammaDelta,
          -MOBILE_MOTION_ROTATE_ABS_MAX_DEG,
          MOBILE_MOTION_ROTATE_ABS_MAX_DEG,
        ),
        MOBILE_MOTION_ROTATE_DEADZONE_DEG,
        MOBILE_MOTION_ROTATE_RANGE_DEG,
      );
      const pitchInput = applyDeadzoneAndNormalize(
        THREE.MathUtils.clamp(
          -motionState.filteredBetaDelta,
          -MOBILE_MOTION_ROTATE_ABS_MAX_DEG,
          MOBILE_MOTION_ROTATE_ABS_MAX_DEG,
        ),
        MOBILE_MOTION_ROTATE_DEADZONE_DEG,
        MOBILE_MOTION_ROTATE_RANGE_DEG,
      );

      if (Math.abs(yawInput) > 0 || Math.abs(pitchInput) > 0) {
        const rotateLimitRad = THREE.MathUtils.degToRad(MOBILE_MOTION_ROTATE_MAX_DEG);
        orbitTarget.copy(motionState.anchorOrbitTarget);
        orbitDistance = motionState.anchorOrbitDistance;
        orbitYaw = motionState.anchorOrbitYaw - yawInput * rotateLimitRad;
        orbitPitch = THREE.MathUtils.clamp(
          motionState.anchorOrbitPitch + pitchInput * rotateLimitRad,
          -Math.PI / 2 + 0.05,
          Math.PI / 2 - 0.05,
        );
        applyOrbit();
        rotated = true;
      }

      const moveInput = applyDeadzoneAndNormalize(
        THREE.MathUtils.clamp(
          -motionState.filteredBetaDelta,
          -MOBILE_MOTION_ROTATE_ABS_MAX_DEG,
          MOBILE_MOTION_ROTATE_ABS_MAX_DEG,
        ),
        MOBILE_MOTION_MOVE_START_DEG,
        MOBILE_MOTION_MOVE_MAX_DEG,
      );

      if (Math.abs(moveInput) > 0) {
        const distance = moveInput >= 0
          ? moveInput * MOBILE_MOTION_MOVE_MAX_DISTANCE_FORWARD
          : moveInput * MOBILE_MOTION_MOVE_MAX_DISTANCE_BACKWARD;
        motionForwardVector.copy(motionState.anchorForward);
        orbitTarget.copy(motionState.anchorOrbitTarget).addScaledVector(motionForwardVector, distance);
        orbitDistance = motionState.anchorOrbitDistance;
        const rotateLimitRad = THREE.MathUtils.degToRad(MOBILE_MOTION_ROTATE_MAX_DEG);
        orbitYaw = motionState.anchorOrbitYaw - yawInput * rotateLimitRad;
        orbitPitch = THREE.MathUtils.clamp(
          motionState.anchorOrbitPitch + pitchInput * rotateLimitRad,
          -Math.PI / 2 + 0.05,
          Math.PI / 2 - 0.05,
        );
        applyOrbit();
        moved = Math.abs(distance) > 1e-6;
      } else if (!rotated) {
        orbitTarget.copy(motionState.anchorOrbitTarget);
        orbitDistance = motionState.anchorOrbitDistance;
        orbitYaw = motionState.anchorOrbitYaw;
        orbitPitch = THREE.MathUtils.clamp(
          motionState.anchorOrbitPitch,
          -Math.PI / 2 + 0.05,
          Math.PI / 2 - 0.05,
        );
        applyOrbit();
      }

      return { rotated, moved };
    }

    function applyOrbit() {
      const cosPitch = Math.cos(orbitPitch);
      const sinPitch = Math.sin(orbitPitch);
      const cosYaw = Math.cos(orbitYaw);
      const sinYaw = Math.sin(orbitYaw);
      const offset = new THREE.Vector3(
        orbitDistance * sinYaw * cosPitch,
        orbitDistance * sinPitch,
        orbitDistance * cosYaw * cosPitch,
      );
      camera.position.copy(orbitTarget).add(offset);
      camera.lookAt(orbitTarget);
    }

    function syncOrbitFromCamera() {
      const offset = camera.position.clone().sub(orbitTarget);
      orbitDistance = Math.max(0.1, offset.length());
      if (orbitDistance <= 0) {
        orbitYaw = 0;
        orbitPitch = 0;
        return;
      }
      orbitYaw = Math.atan2(offset.x, offset.z);
      orbitPitch = Math.asin(THREE.MathUtils.clamp(offset.y / orbitDistance, -1, 1));
    }

    function resetView() {
      if (!hasInitialOrbit) return;
      orbitTarget.copy(initialOrbitTarget);
      orbitYaw = initialOrbitYaw;
      orbitPitch = initialOrbitPitch;
      orbitDistance = initialOrbitDistance;
      applyOrbit();
      lastCameraPos.copy(camera.position);
      if (motionState.enabled) {
        resetMotionBaseline();
        resetMotionAnchor();
      }
    }

    function resetViewState() {
      resetView();
      updateFov(30);
    }

    window.addEventListener('keydown', (event) => {
      if (event.code === 'Escape') {
        const xrSession = renderer.xr.getSession();
        if (xrSession) {
          event.preventDefault();
          void xrSession.end();
          return;
        }
      }
      if (event.code in orbitKeyState) {
        orbitKeyState[event.code] = true;
        event.preventDefault();
      }
    });

    window.addEventListener('keyup', (event) => {
      if (event.code in orbitKeyState) {
        orbitKeyState[event.code] = false;
        event.preventDefault();
      }
    });

    function resize() {
      const width = frameEl.clientWidth;
      const height = frameEl.clientHeight;

      const canvas = renderer.domElement;
      const needResize = canvas.width !== width || canvas.height !== height;

      if (needResize) {
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }
    }

    const resizeObserver = new ResizeObserver(() => {
      setTimeout(function () { resize(); }, 50);
    });
    resizeObserver.observe(frameEl);

    const SHORT_MAX_FRAMES = 16;
    const MEDIUM_MAX_FRAMES = 32;
    const FRAME_LIMIT_MODE_SHORT = 'short';
    const FRAME_LIMIT_MODE_MEDIUM = 'medium';
    const FRAME_LIMIT_MODE_LONG = 'long';
    const IS_IOS_DEVICE = /iPad|iPhone|iPod/.test(navigator.userAgent)
      || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const XR_PRELOAD_AHEAD_FRAMES = 0;
    const XR_MAX_RESIDENT_MESHES = Number.POSITIVE_INFINITY;
    const XR_WARMUP_FRAMES = Number.POSITIVE_INFINITY;
    const IOS_PRELOAD_AHEAD_FRAMES = 2;
    const IOS_MAX_RESIDENT_MESHES = 6;
    const DESKTOP_PRELOAD_AHEAD_FRAMES = 6;
    const DESKTOP_MAX_RESIDENT_MESHES = 18;
    const IOS_WARMUP_BYTE_CONCURRENCY = 2;
    const DESKTOP_WARMUP_BYTE_CONCURRENCY = 2;
    const IOS_CACHE_SCENE_CONCURRENCY = 2;
    const DESKTOP_CACHE_SCENE_CONCURRENCY = 2;
    const IOS_CACHE_FRAME_BYTE_CONCURRENCY = 2;
    const DESKTOP_CACHE_FRAME_BYTE_CONCURRENCY = 2;
    let maxFramesMode = FRAME_LIMIT_MODE_SHORT;
    let maxFramesToLoad = SHORT_MAX_FRAMES;

    function getRuntimeMemoryPolicy() {
      if (renderer.xr.isPresenting) {
        return {
          preloadAheadFrames: XR_PRELOAD_AHEAD_FRAMES,
          maxResidentMeshes: XR_MAX_RESIDENT_MESHES,
          releaseBytesAfterMesh: true,
          warmupFrameCount: XR_WARMUP_FRAMES,
        };
      }
      if (IS_IOS_DEVICE) {
        return {
          preloadAheadFrames: DESKTOP_PRELOAD_AHEAD_FRAMES,
          maxResidentMeshes: (
            maxFramesMode === FRAME_LIMIT_MODE_LONG
            || maxFramesMode === FRAME_LIMIT_MODE_MEDIUM
          )
            ? Number.POSITIVE_INFINITY
            : DESKTOP_MAX_RESIDENT_MESHES,
          releaseBytesAfterMesh: false,
          warmupFrameCount: Number.POSITIVE_INFINITY,
        };
      }
      return {
        preloadAheadFrames: DESKTOP_PRELOAD_AHEAD_FRAMES,
        maxResidentMeshes: (
          maxFramesMode === FRAME_LIMIT_MODE_LONG
          || maxFramesMode === FRAME_LIMIT_MODE_MEDIUM
        )
          ? Number.POSITIVE_INFINITY
          : DESKTOP_MAX_RESIDENT_MESHES,
        releaseBytesAfterMesh: false,
        warmupFrameCount: Number.POSITIVE_INFINITY,
      };
    }

    function parseFrameLimitMode(value) {
      const raw = String(value ?? '').trim().toLowerCase();
      if (raw === FRAME_LIMIT_MODE_MEDIUM || raw === '32') {
        return FRAME_LIMIT_MODE_MEDIUM;
      }
      if (raw === FRAME_LIMIT_MODE_LONG || raw === 'all' || raw === 'infinity') {
        return FRAME_LIMIT_MODE_LONG;
      }
      const parsed = Number.parseInt(raw, 10);
      if (Number.isFinite(parsed) && parsed > MEDIUM_MAX_FRAMES) {
        return FRAME_LIMIT_MODE_LONG;
      }
      if (parsed === MEDIUM_MAX_FRAMES) {
        return FRAME_LIMIT_MODE_MEDIUM;
      }
      return FRAME_LIMIT_MODE_SHORT;
    }

    function applyFrameLimitMode(mode) {
      if (mode === FRAME_LIMIT_MODE_LONG) {
        maxFramesMode = FRAME_LIMIT_MODE_LONG;
        maxFramesToLoad = Number.POSITIVE_INFINITY;
        return;
      }
      if (mode === FRAME_LIMIT_MODE_MEDIUM) {
        maxFramesMode = FRAME_LIMIT_MODE_MEDIUM;
        maxFramesToLoad = MEDIUM_MAX_FRAMES;
        return;
      }
      maxFramesMode = FRAME_LIMIT_MODE_SHORT;
      maxFramesToLoad = SHORT_MAX_FRAMES;
    }

    function limitFrames(list) {
      return list.slice(0, maxFramesToLoad);
    }

    let params = new URLSearchParams(document.location.search);
    const paramFrameLimit = params.get('n') ?? params.get('maxFrames');
    if (paramFrameLimit != null) {
      applyFrameLimitMode(parseFrameLimitMode(paramFrameLimit));
    }

    let frames = [];
    let currentIndex = 0;
    let isPlaying = false;
    let fps = 30;
    let speedMultiplier = 1;
    let isLoadingFrame = false;
    let playbackTimer = null;
    let isCaching = false;
    let isSceneSwitching = false;
    let isPageUnloading = false;
    let cachingTaskId = 0;
    let cachingProgress = 0;
    let viewerPreviewFallbackQueue = [];

    window.addEventListener('beforeunload', () => {
      isPageUnloading = true;
    });
    window.addEventListener('pagehide', () => {
      isPageUnloading = true;
    });

    const playBtn = document.querySelector('.play-button');
    const playIcon = document.querySelector('.play-icon');
    const cachingPercentEl = document.querySelector('.caching-percent');
    const frameIndicatorEls = document.querySelectorAll('.frame-indicator');
    const progressEl = document.querySelector('.progress');
    const timeCurrentEl = document.querySelector('.time-current');
    const timeTotalEl = document.querySelector('.time-total');
    const speedSelect = document.querySelector('.speed-select');
    const resetBtn = document.querySelector('.reset-button');
    const viewerCloseBtn = document.querySelector('.viewer-close-button');
    const sceneTitleOverlayEl = document.querySelector('.scene-title-overlay');
    const viewerPreviewOverlayEl = document.querySelector('.viewer-preview-overlay');
    const viewerPreviewImgEl = viewerPreviewOverlayEl?.querySelector('img') || null;
    const frameLimitSelectEl = document.querySelector('.frame-limit-select');
    const fovSlider = document.querySelector('.fov-slider');
    const fovValue = document.querySelector('.fov-value');
    const controlsRightEl = document.querySelector('.controls-right');
    const languageSelectEl = document.querySelector('.language-select');

    applyStaticI18n();

    if (languageSelectEl) {
      languageSelectEl.value = UI_LANG;
      languageSelectEl.addEventListener('change', () => {
        const nextLang = normalizeLanguageCode(languageSelectEl.value) || 'en';
        if (nextLang === UI_LANG) return;
        try {
          localStorage.setItem(LANG_STORAGE_KEY, nextLang);
        } catch {
        }
        window.location.reload();
      });
    }

    if (frameLimitSelectEl) {
      frameLimitSelectEl.value = maxFramesMode;
      frameLimitSelectEl.addEventListener('change', () => {
        applyFrameLimitMode(frameLimitSelectEl.value);
        frameLimitSelectEl.value = maxFramesMode;
      });
    }

    if (vrButton) {
      vrButton.style.zIndex = '3';
      vrButton.setAttribute('aria-label', t('enterVr'));
      vrButton.setAttribute('title', t('enterVr'));
      if (controlsRightEl) {
        controlsRightEl.appendChild(vrButton);
      } else {
        document.body.appendChild(vrButton);
      }
    }

    function updateSpatialToggleButtonUI() {
      if (!resetBtn) return;
      const isOn = motionState.enabled;
      const key = isOn ? 'spatialOn' : 'spatialOff';
      resetBtn.textContent = t(key);
      resetBtn.setAttribute('aria-label', t(key));
      resetBtn.setAttribute('title', t(key));
    }

    async function toggleSpatialFromButton() {
      const nextEnabled = !motionState.enabled;

      if (!nextEnabled) {
        setMotionEnabled(false);
        return;
      }

      if (!IS_MOBILE_DEVICE || !motionState.supported) {
        setMotionEnabled(false);
        return;
      }

      const granted = await requestMotionPermissionIfNeeded();
      motionState.permissionDenied = !granted;
      setMotionEnabled(granted);
    }

    updateSpatialToggleButtonUI();

    function updateFov(value) {
      const nextFov = Math.min(90, Math.max(10, Number(value)));
      camera.fov = nextFov;
      camera.updateProjectionMatrix();
      fovValue.textContent = `${Math.round(nextFov)}°`;
      fovSlider.value = String(nextFov);
    }

    function formatTime(seconds) {
      if (!Number.isFinite(seconds) || seconds < 0) return '00:00';
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }

    function extractFrameSequence(name) {
      if (typeof name !== 'string') return null;
      const match = name.match(/(\d+)(?!.*\d)/);
      if (!match) return null;
      const parsed = Number(match[1]);
      return Number.isFinite(parsed) ? parsed : null;
    }

    function getFrameTimeUnits(index, frameList = frames) {
      const frame = frameList[index];
      if (!frame) return index;
      if (Number.isFinite(frame.timeUnits)) {
        return frame.timeUnits;
      }
      const parsed = extractFrameSequence(frame.name);
      if (Number.isFinite(parsed)) {
        frame.timeUnits = parsed;
        return parsed;
      }
      frame.timeUnits = index;
      return frame.timeUnits;
    }

    function getTypicalFrameStepUnits(frameList = frames) {
      if (!Array.isArray(frameList) || frameList.length < 2) return 1;
      let minPositive = Number.POSITIVE_INFINITY;
      for (let i = 1; i < frameList.length; i += 1) {
        const prev = getFrameTimeUnits(i - 1, frameList);
        const curr = getFrameTimeUnits(i, frameList);
        const delta = curr - prev;
        if (delta > 0 && delta < minPositive) {
          minPositive = delta;
        }
      }
      return Number.isFinite(minPositive) ? minPositive : 1;
    }

    function getNextFrameDelayMs(index, frameList = frames) {
      const total = frameList.length;
      if (total <= 1) {
        return 1000 / (fps * Math.max(speedMultiplier, 0.001));
      }

      const currentUnits = getFrameTimeUnits(index, frameList);
      const nextIndex = (index + 1) % total;
      const nextUnits = getFrameTimeUnits(nextIndex, frameList);

      let deltaUnits = nextUnits - currentUnits;
      if (deltaUnits <= 0) {
        const firstUnits = getFrameTimeUnits(0, frameList);
        const lastUnits = getFrameTimeUnits(total - 1, frameList);
        const typicalStep = getTypicalFrameStepUnits(frameList);
        const cycleUnits = Math.max(typicalStep, (lastUnits - firstUnits) + typicalStep);
        deltaUnits += cycleUnits;
      }

      const safeSpeed = Math.max(speedMultiplier, 0.001);
      const delayMs = (1000 * deltaUnits) / (fps * safeSpeed);
      return Math.max(1, delayMs);
    }

    function updateIndicator() {
      const total = frames.length || 0;
      const idx = total ? (currentIndex + 1) : 0;
      for (const el of frameIndicatorEls) {
        el.textContent = `${idx}/${total}`;
      }
    }

    function updateProgress() {
      const total = frames.length || 0;
      progressEl.max = total > 0 ? String(total - 1) : '0';
      progressEl.value = total > 0 ? String(currentIndex) : '0';
      const safeFps = Math.max(fps, 0.001);
      const firstUnits = total > 0 ? getFrameTimeUnits(0, frames) : 0;
      const lastUnits = total > 0 ? getFrameTimeUnits(total - 1, frames) : 0;
      const currentUnits = total > 0 ? getFrameTimeUnits(currentIndex, frames) : 0;
      const totalSeconds = total > 0 ? Math.max(0, (lastUnits - firstUnits) / safeFps) : 0;
      const currentSeconds = total > 0 ? Math.max(0, (currentUnits - firstUnits) / safeFps) : 0;
      timeCurrentEl.textContent = formatTime(currentSeconds);
      timeTotalEl.textContent = formatTime(totalSeconds);
    }

    function showViewerInterface() {
      document.querySelector('.container').classList.add('hidden');
      document.querySelector('.canvas-container').classList.remove('invisible');
    }

    function showImportInterface() {
      setPlaying(false);
      document.querySelector('.canvas-container').classList.add('invisible');
      document.querySelector('.container').classList.remove('hidden');
      hideViewerPreviewOverlay();
      sceneSelectionRequestId += 1;
      clearSceneCardLoadingState();
      if (urlDirSelectEl) {
        urlDirSelectEl.value = '';
      }
      selectedSceneDirectory = '';
      setCacheButtonState({
        label: cacheButtonIdleLabel,
        progress: 0,
        disabled: false,
      });
      setViewerSceneTitle('');
    }

    function setViewerSceneTitle(title) {
      if (!sceneTitleOverlayEl) return;
      const safeText = String(title || '').trim();
      sceneTitleOverlayEl.textContent = safeText;
      sceneTitleOverlayEl.classList.toggle('has-text', safeText.length > 0);
    }

    function hideViewerPreviewOverlay() {
      viewerPreviewFallbackQueue = [];
      if (!viewerPreviewOverlayEl) return;
      viewerPreviewOverlayEl.classList.remove('is-visible');
      if (viewerPreviewImgEl) {
        viewerPreviewImgEl.removeAttribute('src');
      }
    }

    function showViewerPreviewOverlay(previewUrls = []) {
      if (!viewerPreviewOverlayEl || !viewerPreviewImgEl) return;
      const candidates = Array.isArray(previewUrls)
        ? previewUrls.map(url => String(url || '').trim()).filter(Boolean)
        : [];
      if (candidates.length === 0) {
        hideViewerPreviewOverlay();
        return;
      }
      const [primary, ...fallbacks] = candidates;
      viewerPreviewFallbackQueue = fallbacks;
      viewerPreviewImgEl.src = primary;
      viewerPreviewOverlayEl.classList.add('is-visible');
    }

    if (viewerPreviewImgEl) {
      viewerPreviewImgEl.addEventListener('error', () => {
        const nextUrl = viewerPreviewFallbackQueue.shift();
        if (nextUrl) {
          viewerPreviewImgEl.src = nextUrl;
          return;
        }
        hideViewerPreviewOverlay();
      });
    }

    function getDirectoryDisplayName(dirUrl) {
      const normalized = normalizeDirectoryUrl(dirUrl);
      const parts = normalized.split('/').filter(Boolean);
      const rawName = parts[parts.length - 1] || '';
      return localizeSceneName(rawName) || rawName;
    }

    function getBaseName(inputPath) {
      const value = String(inputPath || '').trim();
      if (!value) return '';
      const parts = value.split(/[/\\]/).filter(Boolean);
      return parts[parts.length - 1] || value;
    }

    async function returnToImportInterface() {
      if (renderer.xr.isPresenting) {
        const xrSession = renderer.xr.getSession();
        if (xrSession) {
          await xrSession.end();
        }
      }
      showImportInterface();
    }

    async function showFrame(index) {
      if (!frames.length || isLoadingFrame) return;
      isLoadingFrame = true;
      currentIndex = (index + frames.length) % frames.length;
      const frame = frames[currentIndex];

      try {
        if (!frame) return;
        const mesh = await ensureFrameMesh(currentIndex);
        if (!mesh) return;

        if (loadedSplat && loadedSplat !== mesh) {
          loadedSplat.visible = false;
        }
        mesh.visible = true;
        loadedSplat = mesh;
        hideViewerPreviewOverlay();

        if (!hasInitialOrbit) {
          syncOrbitFromCamera();
          initialOrbitTarget = orbitTarget.clone();
          initialOrbitYaw = orbitYaw;
          initialOrbitPitch = orbitPitch;
          initialOrbitDistance = orbitDistance;
          hasInitialOrbit = true;
          lastCameraPos.copy(camera.position);
        }
      } catch (error) {
        if (frame) {
          frame.meshPromise = null;
        }
        throw error;
      } finally {
        isLoadingFrame = false;
      }

      updateIndicator();
      updateProgress();
      trimFrameMeshes(currentIndex, frames);
      preloadFrames(currentIndex, frames);

      if (renderer.xr.isPresenting && vrFrameInitialized && pendingVrRefit) {
        fitVrWindowToSplat();
        pendingVrRefit = false;
      }
    }

    async function nextFrame() { await showFrame(currentIndex + 1); }

    function scheduleNextPlaybackTick() {
      if (renderer.xr.isPresenting) return;
      if (!isPlaying || playbackTimer || !frames.length) return;
      const delayMs = getNextFrameDelayMs(currentIndex, frames);
      playbackTimer = setTimeout(async () => {
        playbackTimer = null;
        if (!isPlaying || !frames.length) return;
        try {
          if (!isLoadingFrame) {
            await nextFrame();
          }
        } catch (error) {
          console.warn('Frame playback failed, will retry on next tick:', error);
        }
        scheduleNextPlaybackTick();
      }, delayMs);
    }

    function startPlayback() {
      scheduleNextPlaybackTick();
    }

    function stopPlayback() {
      if (playbackTimer) {
        clearTimeout(playbackTimer);
        playbackTimer = null;
      }
    }

    function setPlaying(val) {
      isPlaying = val;
      playBtn.classList.toggle('is-playing', isPlaying);
      playBtn.setAttribute('aria-label', isPlaying ? t('pause') : t('play'));
      if (isPlaying) {
        if (renderer.xr.isPresenting) {
          resetXrPlaybackClock();
          stopPlayback();
          return;
        }
        startPlayback();
      } else {
        stopPlayback();
        resetXrPlaybackClock();
      }
    }

    function updatePlayButtonLoadingState() {
      const isBusy = isCaching || isSceneSwitching;
      playBtn.classList.toggle('is-loading', isBusy);
      playBtn.disabled = isBusy;
    }

    function setSceneSwitching(val) {
      isSceneSwitching = Boolean(val);
      updatePlayButtonLoadingState();
    }

    function setCaching(val) {
      isCaching = val;
      updatePlayButtonLoadingState();
      if (!isCaching) {
        cachingProgress = 0;
      }
      if (cachingPercentEl) {
        cachingPercentEl.classList.toggle('is-visible', isCaching);
        cachingPercentEl.textContent = `${Math.round(cachingProgress)}%`;
      }
      if (isCaching) {
        setPlaying(false);
      }
    }

    function setCachingProgress(value) {
      cachingProgress = Math.max(0, Math.min(100, Number(value) || 0));
      if (cachingPercentEl) {
        cachingPercentEl.textContent = `${Math.round(cachingProgress)}%`;
      }
    }

    async function togglePlaybackFromUi() {
      if (isCaching || isSceneSwitching) return;
      if (isPlaying) {
        setPlaying(false);
        return;
      }
      if (!frames.length) return;
      await startPlaybackAfterWarmup(frames);
    }

    function hasMissingFrameMeshes(frameList = frames) {
      if (!Array.isArray(frameList) || frameList.length === 0) return false;
      return frameList.some(frame => !frame?.mesh);
    }

    function cancelCachingTask() {
      cachingTaskId += 1;
      setCaching(false);
    }

    async function runIndexTasksWithConcurrency(totalCount, maxConcurrency, runTask, onProgress) {
      if (!Number.isFinite(totalCount) || totalCount <= 0) return;
      const safeTotal = Math.floor(totalCount);
      const safeConcurrency = Math.max(1, Math.min(safeTotal, Math.floor(maxConcurrency) || 1));
      let nextIndex = 0;
      let completed = 0;

      const worker = async () => {
        while (true) {
          const index = nextIndex;
          nextIndex += 1;
          if (index >= safeTotal) return;
          await runTask(index);
          completed += 1;
          if (typeof onProgress === 'function') {
            onProgress(completed, safeTotal, index);
          }
        }
      };

      const workers = Array.from({ length: safeConcurrency }, () => worker());
      await Promise.all(workers);
    }

    async function warmupPlaybackAssets(frameList = frames) {
      if (!Array.isArray(frameList) || frameList.length === 0) return true;

      const { maxResidentMeshes, warmupFrameCount, preloadAheadFrames } = getRuntimeMemoryPolicy();
      const canKeepAllMeshesResident = Number.isFinite(maxResidentMeshes)
        && frameList.length <= maxResidentMeshes;
      const shouldWarmupMeshes = renderer.xr.isPresenting
        || !Number.isFinite(maxResidentMeshes)
        || canKeepAllMeshesResident;
      const defaultWarmupCount = shouldWarmupMeshes
        ? frameList.length
        : Math.min(frameList.length, Math.max(1, preloadAheadFrames + 1));
      const targetWarmupCount = Number.isFinite(warmupFrameCount)
        ? Math.max(1, Math.min(defaultWarmupCount, warmupFrameCount))
        : defaultWarmupCount;
      const warmupConcurrency = shouldWarmupMeshes
        ? 1
        : (IS_IOS_DEVICE ? IOS_WARMUP_BYTE_CONCURRENCY : DESKTOP_WARMUP_BYTE_CONCURRENCY);
      const cancellationError = new Error('Warmup cancelled');
      cancellationError.name = 'WarmupCancelledError';

      if (shouldWarmupMeshes && !hasMissingFrameMeshes(frameList)) {
        return true;
      }

      const taskId = ++cachingTaskId;
      setCaching(true);
      setCachingProgress(0);

      try {
        await runIndexTasksWithConcurrency(
          targetWarmupCount,
          warmupConcurrency,
          async (i) => {
            if (taskId !== cachingTaskId) throw cancellationError;
            if (shouldWarmupMeshes) {
              await ensureFrameMesh(i, frameList);
            } else {
              await ensureFrameBytes(i, frameList);
            }
            if (taskId !== cachingTaskId) throw cancellationError;
          },
          (completed) => {
            if (taskId !== cachingTaskId) return;
            setCachingProgress((completed / targetWarmupCount) * 100);
          },
        );
        return taskId === cachingTaskId;
      } catch (error) {
        if (error?.name === 'WarmupCancelledError') {
          return false;
        }
        throw error;
      } finally {
        if (taskId === cachingTaskId) {
          setCaching(false);
        }
      }
    }

    async function startPlaybackAfterWarmup(frameList = frames) {
      if (isCaching) return false;
      if (!Array.isArray(frameList) || frameList.length === 0) return false;
      if (!loadedSplat || !loadedSplat.isInitialized) {
        await showFrame(currentIndex);
      }
      const warmupDone = await warmupPlaybackAssets(frameList);
      if (!warmupDone) return false;
      setPlaying(true);
      return true;
    }

    playBtn.addEventListener('click', async () => {
      await togglePlaybackFromUi();
    });

    const CANVAS_CLICK_MOVE_THRESHOLD_PX = 8;
    let canvasPointerDownPos = null;

    sparkCanvasEl.addEventListener('pointerdown', (event) => {
      if (!event.isPrimary || event.button !== 0) {
        canvasPointerDownPos = null;
        return;
      }
      canvasPointerDownPos = {
        pointerId: event.pointerId,
        x: event.clientX,
        y: event.clientY,
      };
    });

    sparkCanvasEl.addEventListener('pointercancel', () => {
      canvasPointerDownPos = null;
    });

    sparkCanvasEl.addEventListener('pointerup', (event) => {
      if (!canvasPointerDownPos) return;
      if (canvasPointerDownPos.pointerId !== event.pointerId) {
        canvasPointerDownPos = null;
        return;
      }
      const deltaX = event.clientX - canvasPointerDownPos.x;
      const deltaY = event.clientY - canvasPointerDownPos.y;
      const movedDistance = Math.hypot(deltaX, deltaY);
      canvasPointerDownPos = null;
      if (movedDistance > CANVAS_CLICK_MOVE_THRESHOLD_PX) return;
      void togglePlaybackFromUi();
    });

    sparkCanvasEl.addEventListener('pointerleave', () => {
      canvasPointerDownPos = null;
    });

    speedSelect.addEventListener('change', () => {
      const v = Number(speedSelect.value);
      if (!Number.isFinite(v) || v <= 0) return;
      speedMultiplier = v;
      if (isPlaying) {
        stopPlayback();
        startPlayback();
      }
    });

    fovSlider.addEventListener('input', () => {
      updateFov(fovSlider.value);
    });

    progressEl.addEventListener('input', () => {
      if (!frames.length) return;
      const index = Number(progressEl.value) || 0;
      setPlaying(false);
      showFrame(index);
    });

    resetBtn.addEventListener('click', async () => {
      await toggleSpatialFromButton();
      resetViewState();
      updateSpatialToggleButtonUI();
    });

    viewerCloseBtn?.addEventListener('click', async () => {
      await returnToImportInterface();
    });

    updateFov(camera.fov);

    let lastAnimationTimeMs = null;

    renderer.setAnimationLoop(function animate(timeMs) {
      const nowMs = Number.isFinite(timeMs) ? timeMs : performance.now();
      if (!Number.isFinite(lastAnimationTimeMs)) {
        lastAnimationTimeMs = nowMs;
      }
      const deltaSeconds = Math.max(0, Math.min(0.1, (nowMs - lastAnimationTimeMs) / 1000));
      lastAnimationTimeMs = nowMs;
      const isInVR = renderer.xr.isPresenting;

      if (!isInVR) {
        if (shouldResetViewAfterVrExit) {
          shouldResetViewAfterVrExit = false;
          resetViewState();
        }
        resize();
        controls.update(camera);

        let isOrbiting = false;

        if (
          orbitKeyState.ArrowLeft ||
          orbitKeyState.ArrowRight ||
          orbitKeyState.ArrowUp ||
          orbitKeyState.ArrowDown
        ) {
          isOrbiting = true;
          syncOrbitFromCamera();
          if (orbitKeyState.ArrowLeft) orbitYaw += orbitSpeed;
          if (orbitKeyState.ArrowRight) orbitYaw -= orbitSpeed;
          if (orbitKeyState.ArrowUp) {
            orbitPitch = Math.min(Math.PI / 2 - 0.05, orbitPitch + orbitSpeed);
          }
          if (orbitKeyState.ArrowDown) {
            orbitPitch = Math.max(-Math.PI / 2 + 0.05, orbitPitch - orbitSpeed);
          }
          applyOrbit();
        }

        const motionResult = applyMobileMotionInput(deltaSeconds);
        if (motionResult.rotated) {
          isOrbiting = true;
        }

        const deltaPos = camera.position.clone().sub(lastCameraPos);
        if (isOrbiting || motionResult.moved) {
          lastCameraPos.copy(camera.position);
        } else if (deltaPos.lengthSq() > 0) {
          orbitTarget.add(deltaPos);
          lastCameraPos.copy(camera.position);
        }
      } else {
        // Keep both frame and 3DGS world-fixed in VR.
        // Place window once when entering VR so the scene starts centered.
        // Keep the window plane fixed at world (0, 0, z).
        if (!vrFrameInitialized) {
          vrFrameGroup.position.set(0, 0, 0);
          vrFrameGroup.rotation.set(0, 0, 0);
          fitVrWindowToSplat();
          vrFrameInitialized = true;
          pendingVrRefit = false;
        }

        if (isPlaying && frames.length > 0 && !isCaching) {
          const nowMs = Number.isFinite(timeMs) ? timeMs : performance.now();
          if (!xrPlaybackClockInitialized) {
            xrPlaybackClockInitialized = true;
            xrPlaybackLastTimestamp = nowMs;
            xrPlaybackElapsedMs = 0;
          } else {
            const deltaMs = Math.max(0, Math.min(250, nowMs - xrPlaybackLastTimestamp));
            xrPlaybackLastTimestamp = nowMs;
            xrPlaybackElapsedMs += deltaMs;
          }

          const frameDelayMs = getNextFrameDelayMs(currentIndex, frames);
          if (!isLoadingFrame && xrPlaybackElapsedMs >= frameDelayMs) {
            xrPlaybackElapsedMs -= frameDelayMs;
            nextFrame().catch((error) => {
              console.warn('VR frame playback failed, will retry on next XR tick:', error);
            });
          }
        } else {
          resetXrPlaybackClock();
        }

      }

      renderer.render(scene, camera);
    });

    const dropZoneEl = document.querySelector('.container');
    const dropUIEl = document.querySelector('.drop-zone');
    const onDragover = function (e) {
      e.preventDefault();
      dropUIEl.classList.add('dragover');
    };
    const onDragLeave = function () {
      dropUIEl.classList.remove('dragover');
    };
    const onDrop = function (e) {
      e.preventDefault();
      dropUIEl.classList.remove('dragover');

      const files = Array.from(e.dataTransfer.files || []);
      if (files.length > 0) {
        loadSplatFiles(files);
      }
    };

    dropZoneEl.addEventListener('dragover', onDragover);
    sparkCanvasEl.addEventListener('dragover', onDragover);

    dropZoneEl.addEventListener('dragleave', onDragLeave);
    sparkCanvasEl.addEventListener('dragleave', onDragLeave);

    dropZoneEl.addEventListener('drop', onDrop);
    sparkCanvasEl.addEventListener('drop', onDrop);

    const fileInput = document.querySelector('#file-input');
    fileInput.onchange = function(event) {
      const files = Array.from(event.target.files || []);
      if (files.length) { loadSplatFiles(files); }
      event.target.value = '';
    };

    dropUIEl.addEventListener('click', () => {
      fileInput.value = '';
      fileInput.click();
    });

    function sortFilesByName(files) {
      return files.slice().sort((a, b) => {
        const aSeq = extractFrameSequence(a?.name);
        const bSeq = extractFrameSequence(b?.name);
        if (Number.isFinite(aSeq) && Number.isFinite(bSeq) && aSeq !== bSeq) {
          return aSeq - bSeq;
        }
        return String(a?.name || '').localeCompare(String(b?.name || ''), undefined, { numeric: true });
      });
    }

    const sceneCache = new Map();

    function getSceneCacheKey(dirUrl) {
      const normalized = normalizeDirectoryUrl(dirUrl);
      return `${normalized}::${maxFramesMode}`;
    }

    function createSceneFramesFromUrls(urls) {
      return limitFrames(urls).map((u, index) => {
        const name = u.split('/').pop().split('?')[0];
        const parsed = extractFrameSequence(name);
        return {
          url: u,
          name,
          timeUnits: Number.isFinite(parsed) ? parsed : index,
          file: null,
          bytes: null,
          mesh: null,
          meshPromise: null,
          bytesPromise: null,
        };
      });
    }

    async function switchToFrameList(nextFrames, {
      warmup = false,
      ensureFirstBytes = false,
      releaseOnlyIfChanged = false,
      showViewerEarly = false,
      viewerPreviewCandidates = [],
    } = {}) {
      cancelCachingTask();
      const previousFrames = frames;
      frames = nextFrames;
      currentIndex = 0;
      setPlaying(false);

      if (!releaseOnlyIfChanged || previousFrames !== frames) {
        releaseFrameListResources(previousFrames);
      }
      if (frames.length === 0) return;
      if (showViewerEarly) {
        showViewerInterface();
        showViewerPreviewOverlay(viewerPreviewCandidates);
      } else {
        hideViewerPreviewOverlay();
      }
      if (ensureFirstBytes) {
        if (showViewerEarly) {
          ensureFrameBytes(0, frames).catch(() => {});
        } else {
          await ensureFrameBytes(0, frames);
        }
      }
      if (renderer.xr.isPresenting) {
        pendingVrRefit = true;
      }
      await showFrame(0);
      resetViewState();
      if (!showViewerEarly) {
        showViewerInterface();
      }
      if (warmup) {
        await startPlaybackAfterWarmup(frames);
      }
    }

    async function loadSplatFiles(files) {
      const ordered = sortFilesByName(files);
      const loadedFrames = limitFrames(ordered.map((f) => ({
        name: f.name,
        timeUnits: Number.isFinite(extractFrameSequence(f.name)) ? extractFrameSequence(f.name) : null,
        file: f,
        bytes: null,
        mesh: null,
        meshPromise: null,
        bytesPromise: null,
      })));

      await switchToFrameList(loadedFrames, {
        warmup: true,
        ensureFirstBytes: true,
      });
      setViewerSceneTitle(getBaseName(ordered[0]?.name));
    }

    var loadedSplat;
    async function setSplatFile(init) {
      const nextSplat = new SplatMesh(init);
      nextSplat.quaternion.set(1, 0, 0, 0);
      nextSplat.scale.setScalar(3);
      nextSplat.visible = false;
      scene.add(nextSplat);
      await nextSplat.initialized;
      nextSplat.visible = true;
      return nextSplat;
    }

    function isDetachedArrayBuffer(buffer) {
      if (!(buffer instanceof ArrayBuffer)) return true;
      try {
        new DataView(buffer);
        return false;
      } catch {
        return true;
      }
    }

    function hasUsableFrameBytes(frame) {
      if (!frame || !(frame.bytes instanceof Uint8Array)) return false;
      if (frame.bytes.byteLength <= 0) return false;
      return !isDetachedArrayBuffer(frame.bytes.buffer);
    }

    async function ensureFrameBytes(index, frameList = frames) {
      const frame = frameList[index];
      if (!frame) return null;
      if (hasUsableFrameBytes(frame)) return frame.bytes;
      if (frame.bytes && !hasUsableFrameBytes(frame)) {
        frame.bytes = null;
        frame.bytesPromise = null;
      }
      if (frame.bytesPromise) return frame.bytesPromise;
      frame.bytesPromise = (async () => {
        const tryFetchFrameBytes = async (url) => {
          const resp = await fetch(url);
          if (!resp.ok) {
            throw new Error(`HTTP ${resp.status}`);
          }
          frame.bytes = new Uint8Array(await resp.arrayBuffer());
          frame.url = url;
          return frame.bytes;
        };

        try {
          if (frame.file) {
            frame.bytes = new Uint8Array(await frame.file.arrayBuffer());
          } else if (frame.url && !frame.bytes) {
            try {
              await tryFetchFrameBytes(frame.url);
            } catch (primaryError) {
              if (STRICT_ASSET_BASE) {
                throw primaryError;
              }
              const fallbackUrls = getFallbackAssetUrls(frame.url);
              let loaded = false;
              for (const fallbackUrl of fallbackUrls) {
                if (fallbackUrl === frame.url) continue;
                try {
                  await tryFetchFrameBytes(fallbackUrl);
                  loaded = true;
                  console.warn('Primary asset URL failed, switched to fallback URL:', fallbackUrl);
                  break;
                } catch {
                  // Try next fallback candidate.
                }
              }
              if (!loaded) {
                throw primaryError;
              }
            }
          }
          return frame.bytes;
        } catch (e) {
          frame.bytesPromise = null;
          throw e;
        }
      })();
      return frame.bytesPromise;
    }

    async function ensureFrameMesh(index, frameList = frames) {
      const frame = frameList[index];
      if (!frame) return null;
      if (frame.mesh) return frame.mesh;
      if (frame.meshPromise) return frame.meshPromise;
      frame.meshPromise = (async () => {
        try {
          if (!hasUsableFrameBytes(frame) && (frame.file || frame.url)) {
            frame.bytes = null;
            frame.bytesPromise = null;
            await ensureFrameBytes(index, frameList);
          }
          const runtimePolicy = getRuntimeMemoryPolicy();
          const bytesForMesh = runtimePolicy.releaseBytesAfterMesh
            ? frame.bytes
            : (frame.bytes ? frame.bytes.slice() : frame.bytes);
          const mesh = await setSplatFile(
            {
            fileBytes: bytesForMesh,
            fileName: frame.name,
            },
          );
          mesh.visible = false;
          frame.mesh = mesh;
          if (runtimePolicy.releaseBytesAfterMesh) {
            frame.bytes = null;
            frame.bytesPromise = null;
          }
          return mesh;
        } catch (e) {
          frame.meshPromise = null;
          throw e;
        }
      })();

      return frame.meshPromise;
    }

    function frameCircularDistance(target, center, total) {
      const direct = Math.abs(target - center);
      return Math.min(direct, total - direct);
    }

    function releaseFrameMesh(frame) {
      if (!frame?.mesh) return;
      const mesh = frame.mesh;
      mesh.visible = false;
      scene.remove(mesh);
      if (typeof mesh.dispose === 'function') {
        mesh.dispose();
      }
      frame.mesh = null;
      frame.meshPromise = null;
    }

    function releaseFrameListResources(frameList, { releaseBytes = false } = {}) {
      if (!Array.isArray(frameList) || frameList.length === 0) return;
      for (const frame of frameList) {
        releaseFrameMesh(frame);
        if (releaseBytes) {
          frame.bytes = null;
          frame.bytesPromise = null;
        }
      }
      if (loadedSplat && !frameList.includes(frames[currentIndex])) {
        loadedSplat = null;
      }
    }

    function trimFrameMeshes(activeIndex = currentIndex, frameList = frames) {
      const { maxResidentMeshes } = getRuntimeMemoryPolicy();
      if (!Number.isFinite(maxResidentMeshes)) return;
      if (!Array.isArray(frameList) || frameList.length <= maxResidentMeshes) return;
      const loaded = [];
      for (let i = 0; i < frameList.length; i += 1) {
        if (frameList[i]?.mesh) loaded.push(i);
      }
      if (loaded.length <= maxResidentMeshes) return;

      loaded.sort((a, b) => frameCircularDistance(b, activeIndex, frameList.length) - frameCircularDistance(a, activeIndex, frameList.length));
      while (loaded.length > maxResidentMeshes) {
        const idx = loaded.shift();
        if (idx == null || idx === activeIndex) continue;
        releaseFrameMesh(frameList[idx]);
      }
    }

    function preloadFrames(activeIndex = currentIndex, frameList = frames) {
      if (!Array.isArray(frameList) || frameList.length === 0) return;
      const pending = [];
      const total = frameList.length;
      const { preloadAheadFrames } = getRuntimeMemoryPolicy();
      const preloadCount = Math.min(preloadAheadFrames, Math.max(0, total - 1));

      for (let step = 1; step <= preloadCount; step += 1) {
        const i = (activeIndex + step) % total;
        if (!frameList[i]?.mesh && !frameList[i]?.meshPromise) {
          pending.push(ensureFrameMesh(i, frameList));
        }
      }
      if (pending.length > 0) {
        Promise.allSettled(pending);
      }
    }

    let splatURL = params.get("url");

    if (splatURL) { loadSplatURL(splatURL); }


    async function loadSceneByDirectory(dirUrl, {
      viewerPreviewCandidates = [],
      selectionRequestId = null,
    } = {}) {
      const normalized = normalizeDirectoryUrl(dirUrl);
      if (selectionRequestId != null && selectionRequestId !== sceneSelectionRequestId) return;
      const cacheKey = getSceneCacheKey(normalized);
      let sceneEntry = sceneCache.get(cacheKey);
      if (!sceneEntry) {
        const urls = await discoverSplatFiles(normalized);
        if (selectionRequestId != null && selectionRequestId !== sceneSelectionRequestId) return;
        sceneEntry = {
          dir: normalized,
          frames: createSceneFramesFromUrls(urls),
        };
        sceneCache.set(cacheKey, sceneEntry);
      }

      await switchToFrameList(sceneEntry.frames, {
        warmup: true,
        ensureFirstBytes: true,
        releaseOnlyIfChanged: true,
        showViewerEarly: true,
        viewerPreviewCandidates,
      });
      if (selectionRequestId != null && selectionRequestId !== sceneSelectionRequestId) return;
      setViewerSceneTitle(getDirectoryDisplayName(normalized));
    }


    async function loadSplatURL(splatURL) {
      const fileName = splatURL.split("/").pop().split("?")[0];
      await switchToFrameList([
        {
          url: splatURL,
          name: fileName,
          timeUnits: Number.isFinite(extractFrameSequence(fileName)) ? extractFrameSequence(fileName) : 0,
          file: null,
          bytes: null,
          mesh: null,
          meshPromise: null,
          bytesPromise: null,
        },
      ]);
      setViewerSceneTitle(fileName);
    }

    async function loadSplatURLs(urls) {
      await switchToFrameList(createSceneFramesFromUrls(urls));
    }

    // Expand a URL pattern with {start..end} into an array of URLs
    // e.g. "/data/frame_{001..050}.spz" → ["/data/frame_001.spz", ..., "/data/frame_050.spz"]
    function expandUrlPattern(input) {
      const match = input.match(/^(.*)\{(\d+)\.\.(\d+)\}(.*)$/);
      if (!match) return null;
      const [, prefix, startStr, endStr, suffix] = match;
      const start = parseInt(startStr, 10);
      const end = parseInt(endStr, 10);
      const padLen = startStr.length;
      const urls = [];
      for (let i = start; i <= end; i++) {
        urls.push(prefix + String(i).padStart(padLen, '0') + suffix);
      }
      return urls;
    }

    const SPLAT_EXTS = ['.ply', '.spz', '.splat', '.ksplat', '.sog'];
    const SCENES_API_URL = './api/scenes';
    const DEFAULT_ASSET_BASE_URL = '';
    let sceneCatalogPromise = null;

    function normalizeCatalogKey(input) {
      return normalizeDirectoryUrl(input).replace(/^\/+|\/+$/g, '');
    }

    function normalizeAssetBaseUrl(input) {
      const raw = String(input ?? '').trim();
      if (!raw) return '';
      if (raw.toLowerCase() === 'local') return '';
      return raw.endsWith('/') ? raw.slice(0, -1) : raw;
    }

    const assetBaseParam = params.get('assetBase');
    const ASSET_BASE_URL = normalizeAssetBaseUrl(assetBaseParam || DEFAULT_ASSET_BASE_URL);
    const STRICT_ASSET_BASE = params.get('strictAssetBase') === '1';

    function getFallbackAssetUrls(inputUrl) {
      if (typeof inputUrl !== 'string' || !ASSET_BASE_URL) return [];
      const normalizedBase = `${ASSET_BASE_URL}/`;
      if (!inputUrl.startsWith(normalizedBase)) return [];
      const relativePath = inputUrl.slice(normalizedBase.length);
      if (!relativePath) return [];
      return [
        `./public/${relativePath}`,
        `/public/${relativePath}`,
        `/projects/4dgs/public/${relativePath}`,
      ];
    }

    function rewriteSceneAssetUrl(inputUrl) {
      if (typeof inputUrl !== 'string' || !ASSET_BASE_URL) return inputUrl;
      if (/^https?:\/\//i.test(inputUrl)) return inputUrl;

      const hashIndex = inputUrl.indexOf('#');
      const queryIndex = inputUrl.indexOf('?');
      let splitIndex = -1;
      if (queryIndex >= 0 && hashIndex >= 0) splitIndex = Math.min(queryIndex, hashIndex);
      else if (queryIndex >= 0) splitIndex = queryIndex;
      else if (hashIndex >= 0) splitIndex = hashIndex;

      const pathOnly = splitIndex >= 0 ? inputUrl.slice(0, splitIndex) : inputUrl;
      const suffix = splitIndex >= 0 ? inputUrl.slice(splitIndex) : '';

      let relativePath = '';
      if (pathOnly.startsWith('./public/')) {
        relativePath = pathOnly.slice('./public/'.length);
      } else if (pathOnly.startsWith('/public/')) {
        relativePath = pathOnly.slice('/public/'.length);
      } else if (pathOnly.startsWith('/projects/4dgs/public/')) {
        relativePath = pathOnly.slice('/projects/4dgs/public/'.length);
      } else {
        return inputUrl;
      }

      return `${ASSET_BASE_URL}/${relativePath}${suffix}`;
    }

    async function loadSceneCatalog() {
      if (sceneCatalogPromise) return sceneCatalogPromise;
      sceneCatalogPromise = (async () => {
        try {
          const apiResp = await fetch(SCENES_API_URL, { cache: 'no-store' });
          if (apiResp.ok) {
            const apiPayload = await apiResp.json();
            if (apiPayload?.scenes && typeof apiPayload.scenes === 'object') {
              return apiPayload.scenes;
            }
          }
          console.warn('Dynamic scenes API returned unexpected payload.');
          return {};
        } catch (e) {
          console.warn('Failed to load dynamic scenes API:', e);
          return {};
        }
      })();
      return sceneCatalogPromise;
    }

    function extractSceneUrls(sceneConfig) {
      if (typeof sceneConfig === 'string') {
        return [rewriteSceneAssetUrl(sceneConfig)];
      }

      if (Array.isArray(sceneConfig)) {
        return sceneConfig.map(url => rewriteSceneAssetUrl(url));
      }
      if (!sceneConfig || typeof sceneConfig !== 'object') return [];

      if (Array.isArray(sceneConfig.urls)) {
        return sceneConfig.urls.map(url => rewriteSceneAssetUrl(url));
      }

      if (typeof sceneConfig.urls === 'string') {
        return [rewriteSceneAssetUrl(sceneConfig.urls)];
      }

      if (typeof sceneConfig.pattern === 'string') {
        const urls = expandUrlPattern(sceneConfig.pattern) || [];
        return urls.map(url => rewriteSceneAssetUrl(url));
      }

      if (typeof sceneConfig.baseUrl === 'string' && Array.isArray(sceneConfig.files)) {
        const baseUrl = sceneConfig.baseUrl.endsWith('/') ? sceneConfig.baseUrl : `${sceneConfig.baseUrl}/`;
        return sceneConfig.files.map(name => rewriteSceneAssetUrl(`${baseUrl}${name}`));
      }

      return [];
    }

    async function discoverSplatFiles(dirUrl) {
      const key = normalizeCatalogKey(dirUrl);
      const catalog = await loadSceneCatalog();
      const sceneConfig = catalog[key];
      if (!sceneConfig) return [];
      const urls = extractSceneUrls(sceneConfig).filter(url => {
        if (typeof url !== 'string') return false;
        const lower = url.toLowerCase();
        return SPLAT_EXTS.some(ext => lower.endsWith(ext));
      });
      return limitFrames(urls);
    }

    const urlDirSelectEl = document.querySelector('.url-dir-select');
    const scenePreviewGridEl = document.querySelector('.scene-preview-grid');
    const cacheAllBtnEl = document.querySelector('.cache-all-button');
    const cacheAllProgressEl = document.querySelector('.cache-all-progress');
    const cacheAllLabelEl = document.querySelector('.cache-all-label');
    let currentDirectory = '/';
    let selectedSceneDirectory = '';
    const scenePreviewByDirectory = new Map();
    let sceneSelectionRequestId = 0;
    let cacheButtonIdleLabel = t('cache');
    let cacheLabelAnimTimer = null;
    let cacheLabelAnimFrame = 0;
    let cacheAllLabelTextEl = null;
    let cacheAllLabelDotsEl = null;

    function ensureCacheLabelParts() {
      if (!cacheAllLabelEl) return;
      if (cacheAllLabelTextEl && cacheAllLabelDotsEl) return;
      cacheAllLabelEl.innerHTML = '';
      cacheAllLabelTextEl = document.createElement('span');
      cacheAllLabelTextEl.className = 'cache-all-label-text';
      cacheAllLabelDotsEl = document.createElement('span');
      cacheAllLabelDotsEl.className = 'cache-all-label-dots';
      cacheAllLabelDotsEl.textContent = '';
      cacheAllLabelEl.appendChild(cacheAllLabelTextEl);
      cacheAllLabelEl.appendChild(cacheAllLabelDotsEl);
    }

    function setCacheLabel(baseLabel, dots = '') {
      ensureCacheLabelParts();
      if (!cacheAllLabelTextEl || !cacheAllLabelDotsEl) return;
      cacheAllLabelTextEl.textContent = baseLabel;
      cacheAllLabelDotsEl.textContent = dots;
    }

    function stopCacheLabelAnimation() {
      if (cacheLabelAnimTimer) {
        clearInterval(cacheLabelAnimTimer);
        cacheLabelAnimTimer = null;
      }
    }

    function startCacheLabelAnimation(baseLabel) {
      stopCacheLabelAnimation();
      ensureCacheLabelParts();
      cacheLabelAnimFrame = 0;
      const dotFrames = ['', '.', '..', '...'];
      setCacheLabel(baseLabel, dotFrames[1]);
      cacheLabelAnimTimer = setInterval(() => {
        cacheLabelAnimFrame = (cacheLabelAnimFrame + 1) % 4;
        setCacheLabel(baseLabel, dotFrames[cacheLabelAnimFrame]);
      }, 350);
    }

    function setCacheButtonState({
      label = t('cache'),
      progress = 0,
      disabled = false,
      isCaching = false,
    } = {}) {
      if (isCaching) {
        startCacheLabelAnimation(label);
      } else {
        stopCacheLabelAnimation();
        setCacheLabel(label, '');
      }
      if (cacheAllProgressEl) {
        let pct = Math.max(0, Math.min(100, progress));
        if (isCaching && pct < 10) {
          pct = 10;
        }
        cacheAllProgressEl.style.width = `${pct}%`;
      }
      if (cacheAllBtnEl) {
        cacheAllBtnEl.disabled = disabled;
        cacheAllBtnEl.classList.toggle('is-caching', isCaching);
      }
    }

    function normalizeDirectoryUrl(input) {
      let dir = (input || '').trim();
      if (!dir) return '/';
      if (!dir.startsWith('/')) dir = '/' + dir;
      if (!dir.endsWith('/')) dir += '/';
      return dir;
    }

    function setScenePreviewStatus(text) {
      if (!scenePreviewGridEl) return;
      scenePreviewGridEl.innerHTML = '';
      const statusEl = document.createElement('div');
      statusEl.className = 'scene-preview-status';
      statusEl.textContent = text;
      scenePreviewGridEl.appendChild(statusEl);
    }

    function parseUrlPathParts(inputUrl) {
      if (typeof inputUrl !== 'string') {
        return { pathOnly: '', suffix: '' };
      }
      const hashIndex = inputUrl.indexOf('#');
      const queryIndex = inputUrl.indexOf('?');
      let splitIndex = -1;
      if (queryIndex >= 0 && hashIndex >= 0) splitIndex = Math.min(queryIndex, hashIndex);
      else if (queryIndex >= 0) splitIndex = queryIndex;
      else if (hashIndex >= 0) splitIndex = hashIndex;
      return {
        pathOnly: splitIndex >= 0 ? inputUrl.slice(0, splitIndex) : inputUrl,
        suffix: splitIndex >= 0 ? inputUrl.slice(splitIndex) : '',
      };
    }

    function replaceUrlFilename(inputUrl, nextFileName) {
      const { pathOnly, suffix } = parseUrlPathParts(inputUrl);
      if (!pathOnly) return '';
      const slashIndex = pathOnly.lastIndexOf('/');
      if (slashIndex < 0) return inputUrl;
      return `${pathOnly.slice(0, slashIndex + 1)}${nextFileName}${suffix}`;
    }

    function getScenePreviewInfo(sceneName, sceneConfig) {
      const sceneFolderBase = rewriteSceneAssetUrl(`/public/${sceneName}/`);
      const defaultPreviewUrl = `${sceneFolderBase}0000.png`;
      const fallbackSet = new Set();
      fallbackSet.add(`./public/${sceneName}/0000.png`);
      fallbackSet.add(`/public/${sceneName}/0000.png`);
      fallbackSet.add(`/projects/4dgs/public/${sceneName}/0000.png`);

      const sceneUrls = extractSceneUrls(sceneConfig);
      let primaryPreviewUrl = defaultPreviewUrl;
      if (sceneUrls.length > 0) {
        const inferredPreview = replaceUrlFilename(sceneUrls[0], '0000.png');
        if (inferredPreview) {
          primaryPreviewUrl = inferredPreview;
          const inferredFallbacks = getFallbackAssetUrls(inferredPreview);
          for (const candidate of inferredFallbacks) {
            fallbackSet.add(candidate);
          }
        }
      }

      fallbackSet.delete(primaryPreviewUrl);
      return {
        primary: primaryPreviewUrl,
        fallbacks: Array.from(fallbackSet),
      };
    }

    function syncScenePreviewSelection() {
      if (!scenePreviewGridEl) return;
      const activeDir = normalizeDirectoryUrl(selectedSceneDirectory);
      const cards = scenePreviewGridEl.querySelectorAll('.scene-card');
      cards.forEach(card => {
        const cardDir = normalizeDirectoryUrl(card.dataset.dir || '');
        card.classList.toggle('is-selected', Boolean(activeDir && activeDir !== '/' && cardDir === activeDir));
      });
    }

    function clearSceneCardLoadingState() {
      if (!scenePreviewGridEl) return;
      const cards = scenePreviewGridEl.querySelectorAll('.scene-card.is-loading');
      cards.forEach(card => card.classList.remove('is-loading'));
    }

    function getScenePreviewCandidatesForDirectory(dirUrl) {
      const normalized = normalizeDirectoryUrl(dirUrl);
      const previewInfo = scenePreviewByDirectory.get(normalized);
      if (!previewInfo) return [];
      return [previewInfo.primary, ...(Array.isArray(previewInfo.fallbacks) ? previewInfo.fallbacks : [])]
        .map(url => String(url || '').trim())
        .filter(Boolean);
    }

    async function handleSceneSelection(dirUrl, previewCandidates = null, requestId = null) {
      const normalized = normalizeDirectoryUrl(dirUrl);
      if (!normalized || normalized === '/') return;
      const activeRequestId = requestId ?? (++sceneSelectionRequestId);
      setSceneSwitching(true);
      selectedSceneDirectory = normalized;
      setViewerSceneTitle(getDirectoryDisplayName(normalized));
      if (urlDirSelectEl) {
        urlDirSelectEl.value = normalized;
      }
      syncScenePreviewSelection();
      const candidates = Array.isArray(previewCandidates) && previewCandidates.length > 0
        ? previewCandidates
        : getScenePreviewCandidatesForDirectory(normalized);
      try {
        await loadFromUrlText(normalized, {
          viewerPreviewCandidates: candidates,
          selectionRequestId: activeRequestId,
        });
        if (activeRequestId !== sceneSelectionRequestId) return;
        await refreshDirectoryDropdown(currentDirectory);
      } finally {
        if (activeRequestId === sceneSelectionRequestId) {
          setSceneSwitching(false);
        }
      }
    }

    async function setScenePreviewCards(baseDir, directories) {
      if (!scenePreviewGridEl) return;
      if (!Array.isArray(directories) || directories.length === 0) {
        setScenePreviewStatus(t('noScenePreviews'));
        return;
      }

      const normalizedBase = normalizeDirectoryUrl(baseDir);
      const catalog = await loadSceneCatalog();
      scenePreviewGridEl.innerHTML = '';
      scenePreviewByDirectory.clear();

      for (const name of directories) {
        const fullDir = normalizeDirectoryUrl(`${normalizedBase}${name}/`);
        const configKey = normalizeCatalogKey(fullDir);
        const sceneConfig = catalog[configKey];
        const previewInfo = getScenePreviewInfo(name, sceneConfig);
        scenePreviewByDirectory.set(fullDir, previewInfo);
        const displayName = localizeSceneName(name);

        const card = document.createElement('button');
        card.type = 'button';
        card.className = 'scene-card';
        card.dataset.dir = fullDir;
        card.title = fullDir;

        const thumb = document.createElement('div');
        thumb.className = 'scene-card-thumb';

        const image = document.createElement('img');
        image.alt = `${displayName} preview`;
        image.loading = 'lazy';
        image.decoding = 'async';
        const fallbackQueue = [...previewInfo.fallbacks];
        image.onerror = () => {
          const nextUrl = fallbackQueue.shift();
          if (nextUrl) {
            image.src = nextUrl;
            return;
          }
          image.remove();
          if (!thumb.querySelector('.scene-card-thumb-fallback')) {
            const fallbackText = document.createElement('span');
            fallbackText.className = 'scene-card-thumb-fallback';
            fallbackText.textContent = t('noPreview');
            thumb.appendChild(fallbackText);
          }
        };
        image.src = previewInfo.primary;
        thumb.appendChild(image);

        const title = document.createElement('span');
        title.className = 'scene-card-title';
        title.textContent = displayName;

        card.appendChild(thumb);
        card.appendChild(title);
        card.addEventListener('click', async () => {
          if (card.classList.contains('is-loading')) return;
          const requestId = ++sceneSelectionRequestId;
          card.classList.add('is-loading');
          try {
            await handleSceneSelection(fullDir, [previewInfo.primary, ...previewInfo.fallbacks], requestId);
          } finally {
            if (requestId === sceneSelectionRequestId) {
              card.classList.remove('is-loading');
            }
          }
        });

        scenePreviewGridEl.appendChild(card);
      }

      syncScenePreviewSelection();
    }

    async function discoverSubdirectories(dirUrl) {
      const normalized = normalizeDirectoryUrl(dirUrl);
      if (normalized !== '/') return [];
      const catalog = await loadSceneCatalog();
      return Object.keys(catalog).sort();
    }

    function setDirectoryOptions(baseDir, directories) {
      if (!urlDirSelectEl) return;
      const normalizedBase = normalizeDirectoryUrl(baseDir);
      const previousSelection = selectedSceneDirectory;
      urlDirSelectEl.innerHTML = '';

      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = t('selectFolder');
      urlDirSelectEl.appendChild(placeholder);

      if (directories.length === 0) {
        const empty = document.createElement('option');
        empty.value = '';
        empty.textContent = t('noFolders');
        empty.disabled = true;
        urlDirSelectEl.appendChild(empty);
      } else {
        for (const name of directories) {
          const fullDir = `${normalizedBase}${name}/`;
          const option = document.createElement('option');
          option.value = fullDir;
          option.textContent = localizeSceneName(name);
          option.title = fullDir;
          urlDirSelectEl.appendChild(option);
        }
      }

      if (previousSelection) {
        const hasPrevious = Array.from(urlDirSelectEl.options).some(option => option.value === previousSelection);
        urlDirSelectEl.value = hasPrevious ? previousSelection : '';
        if (!hasPrevious) {
          selectedSceneDirectory = '';
        }
      } else {
        urlDirSelectEl.value = '';
      }
    }

    async function refreshDirectoryDropdown(baseDir = currentDirectory) {
      currentDirectory = normalizeDirectoryUrl(baseDir);
      try {
        if (urlDirSelectEl) {
          urlDirSelectEl.disabled = true;
          urlDirSelectEl.innerHTML = `<option value="">${t('loadingFolders')}</option>`;
        }
        setScenePreviewStatus(t('loadingScenePreviews'));
        const dirs = await discoverSubdirectories(currentDirectory);
        setDirectoryOptions(currentDirectory, dirs);
        await setScenePreviewCards(currentDirectory, dirs);
      } catch (e) {
        console.error('Directory discovery failed:', e);
        if (urlDirSelectEl) {
          urlDirSelectEl.innerHTML = `<option value="">${t('folderUnavailable')}</option>`;
        }
        setScenePreviewStatus(t('scenePreviewsUnavailable'));
      } finally {
        if (urlDirSelectEl) {
          urlDirSelectEl.disabled = false;
        }
      }
    }

    async function loadFromUrlText(raw, {
      viewerPreviewCandidates = [],
      selectionRequestId = null,
    } = {}) {
      if (!raw) return;

      // 1) Try pattern expansion: /data/f_{001..050}.spz
      const patternUrls = expandUrlPattern(raw);
      if (patternUrls) {
        await loadSplatURLs(patternUrls);
        return true;
      }

      // 2) If URL has no file extension, treat as directory → discover splat files
      const lastSegment = raw.split('/').pop().split('?')[0];
      const hasExt = lastSegment.includes('.') && SPLAT_EXTS.some(ext => lastSegment.toLowerCase().endsWith(ext));
      if (!hasExt) {
        try {
          const normalized = normalizeDirectoryUrl(raw);
          const cacheKey = getSceneCacheKey(normalized);
          // Use in-memory cache first so returning to import is instant.
          if (!sceneCache.has(cacheKey)) {
            const urls = await discoverSplatFiles(normalized);
            if (urls.length === 0) {
              alert(t('noSplatFilesAtUrl'));
              return false;
            }
            sceneCache.set(cacheKey, {
              dir: normalized,
              frames: createSceneFramesFromUrls(urls),
            });
          }
          await loadSceneByDirectory(normalized, {
            viewerPreviewCandidates,
            selectionRequestId,
          });
        } catch (e) {
          if (isPageUnloading) {
            return false;
          }
          console.error('Scene load failed:', e);
          alert(t('failedToLoadScene', { message: e?.message || e }));
          showImportInterface();
          return false;
        }
        return true;
      }

      // 3) Single file URL
      const url = new URL(window.location);
      await loadSplatURL(raw);
      url.searchParams.set('url', raw);
      history.pushState(null, '', url);
      return true;
    }

    async function cacheDirectoryScene(dirUrl) {
      const normalized = normalizeDirectoryUrl(dirUrl);
      const cacheKey = getSceneCacheKey(normalized);
      const urls = await discoverSplatFiles(normalized);
      if (urls.length === 0) return false;

      let sceneEntry = sceneCache.get(cacheKey);
      if (!sceneEntry) {
        sceneEntry = {
          dir: normalized,
          frames: [],
        };
      }

      const existingByUrl = new Map(sceneEntry.frames.map(frame => [frame.url, frame]));
      sceneEntry.frames = urls.map(url => {
        const existing = existingByUrl.get(url);
        if (existing) return existing;
        const [nextFrame] = createSceneFramesFromUrls([url]);
        return nextFrame;
      });
      sceneCache.set(cacheKey, sceneEntry);

      const frameByteConcurrency = IS_IOS_DEVICE
        ? IOS_CACHE_FRAME_BYTE_CONCURRENCY
        : DESKTOP_CACHE_FRAME_BYTE_CONCURRENCY;

      await runIndexTasksWithConcurrency(sceneEntry.frames.length, frameByteConcurrency, async (i) => {
        await ensureFrameBytes(i, sceneEntry.frames);
        if (IS_IOS_DEVICE) {
          sceneEntry.frames[i].bytes = null;
          sceneEntry.frames[i].bytesPromise = null;
        }
      });
      return true;
    }

    async function cacheAllScenesFromCurrentDirectory() {
      const dirs = await discoverSubdirectories(currentDirectory);
      const targets = dirs.map(name => `${normalizeDirectoryUrl(currentDirectory)}${name}/`);
      if (targets.length === 0) {
        cacheButtonIdleLabel = t('cache');
        setCacheButtonState({
          label: t('noScenesFound'),
          progress: 0,
          disabled: false,
          isCaching: false,
        });
        return;
      }

      setCacheButtonState({
        label: t('cachingProgress', { done: 0, total: targets.length }),
        progress: 0,
        disabled: true,
        isCaching: true,
      });

      const sceneConcurrency = IS_IOS_DEVICE
        ? IOS_CACHE_SCENE_CONCURRENCY
        : DESKTOP_CACHE_SCENE_CONCURRENCY;

      let done = 0;
      await runIndexTasksWithConcurrency(
        targets.length,
        sceneConcurrency,
        async (index) => {
          const dir = targets[index];
          try {
            await cacheDirectoryScene(dir);
          } catch (e) {
            console.warn('Cache scene failed:', dir, e);
          }
        },
        (completed) => {
          done = completed;
          setCacheButtonState({
            label: t('cachingProgress', { done, total: targets.length }),
            progress: (done / targets.length) * 100,
            disabled: true,
            isCaching: true,
          });
        },
      );

      cacheButtonIdleLabel = t('cachedProgress', { done, total: targets.length });
      setCacheButtonState({
        label: cacheButtonIdleLabel,
        progress: 100,
        disabled: false,
        isCaching: false,
      });
    }

    urlDirSelectEl?.addEventListener('change', async () => {
      const selected = urlDirSelectEl.value;
      if (!selected) return;
      await handleSceneSelection(selected);
    });

    cacheAllBtnEl?.addEventListener('click', async () => {
      await cacheAllScenesFromCurrentDirectory();
    });

    refreshDirectoryDropdown('/');
    setCacheButtonState({
      label: cacheButtonIdleLabel,
      progress: 0,
      disabled: false,
    });

    
  </script>
  <div class="canvas-container invisible">
    <div class="viewer-window">
      <div class="viewer-stack">
        <div class="window-frame">
          <div class="logo">
            <img src="./pico-logo.png" alt="Spark Logo" />
          </div>
          <div class="scene-title-overlay" aria-live="polite"></div>
          <button class="viewer-close-button" type="button" aria-label="Close">✕</button>
          <div class="viewer-preview-overlay" aria-hidden="true">
            <img alt="Scene preview" />
          </div>
          <canvas class="spark-canvas"></canvas>
        </div>
        <div class="controls">
          <div class="controls-left">
            <button class="play-button play-toggle" data-i18n-aria-label="play" aria-label="Play">
              <span class="play-icon" aria-hidden="true">▶</span>
              <span class="loading-spinner" aria-hidden="true"></span>
            </button>
            <span class="caching-percent" aria-live="polite">0%</span>
          </div>
          <div class="progress-wrap">
            <span class="time time-current">00:00</span>
            <input class="progress" type="range" min="0" max="0" step="1" value="0" />
            <span class="time time-total">00:00</span>
            <span class="frame-indicator frame-indicator-progress">0/0</span>
          </div>
          <div class="controls-right">
            <span class="frame-indicator frame-indicator-actions">0/0</span>
            <select class="speed-select">
              <option value="0.5">0.5x</option>
              <option value="1" selected>1x</option>
              <option value="1.5">1.5x</option>
              <option value="2">2x</option>
              <option value="3">3x</option>
            </select>
            <div class="fov-wrap">
              <span class="fov-label">FOV</span>
              <input class="fov-slider" type="range" min="10" max="90" step="1" value="30" />
              <span class="fov-value">30°</span>
            </div>
            <button class="reset-button" data-i18n-key="spatialOff">Spatial Off</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="container">
    <div class="drop-container">
      <h1 class="hero-title" data-i18n-key="heroTitle">Pico 6DoF Player</h1>
      <div class="hero-logo">
        <a href="./"><img src="./pico-viewer.png" alt="Pico Viewer Logo" /></a>
      </div>
      <div class="language-row">
        <div class="language-group">
          <span class="language-label" data-i18n-key="language">Language</span>
          <select class="url-select language-select" aria-label="Language">
            <option value="zh" data-i18n-key="langZh">中文</option>
            <option value="en" data-i18n-key="langEn">English</option>
          </select>
        </div>
      </div>
      <div class="drop-zone" data-i18n-key="dragDrop">Drag and drop splat (.ply, .sog, .spz, .splat, .ksplat) here</div>
      <input id="file-input" class="hidden" accept=".ply,.spz,.splat,.ksplat,.sog" type="file" multiple />
      <form class="url-form">
        <div class="scene-preview-grid" aria-live="polite"></div>
        <div class="url-row">
          <div class="frame-limit-wrap" data-i18n-title="frameRange" title="Frame range">
            <select class="frame-limit-select" data-i18n-aria-label="frameRange" aria-label="Frame range">
              <option value="short" data-i18n-key="shortFrames" selected>Short (16 Frames)</option>
              <option value="medium" data-i18n-key="mediumFrames">Medium (32 Frames)</option>
              <option value="long" data-i18n-key="longFrames">Long (All Frames)</option>
            </select>
          </div>
          <button type="button" class="cache-all-button">
            <span class="cache-all-progress" aria-hidden="true"></span>
            <span class="cache-all-label" data-i18n-key="cache">Cache</span>
          </button>
        </div>
      </form>
    </div>
  </div>
</body>
</html>
