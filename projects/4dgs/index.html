<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pico 6DoF</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      color: #fff;
      background: rgb(56, 56, 62);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }

    .container {
      display: flex;
      align-items: center;
      width: 100%;
      height: 100vh;
      background-color: rgb(43, 41, 40);
      margin: 0;
      padding: 0;
      position: relative;
      z-index: 3;
    }

    .drop-container {
      width: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .spark-canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .invisible {
      display: none;
    }

    .canvas-container {
      position: fixed;
      inset: 0;
      background: rgb(56, 56, 62);
      z-index: 2;
    }

    .logo {
      position: absolute;
      top: clamp(8px, 1.8vw, 16px);
      left: clamp(8px, 1.8vw, 16px);
      z-index: 2;
      background: rgba(255, 255, 255, 0.2);
      padding: clamp(4px, 0.9vw, 6px) clamp(6px, 1.2vw, 8px);
      border-radius: clamp(8px, 1.4vw, 10px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
      backdrop-filter: blur(10px) saturate(140%);
      -webkit-backdrop-filter: blur(10px) saturate(140%);
      border: 1px solid rgba(255, 255, 255, 0.25);
    }

    .logo img {
      width: clamp(52px, 9vw, 80px);
      max-width: 24vw;
      height: auto;
      display: block;
    }

    .hero-logo {
      text-align: center;
      margin-bottom: 2rem;
    }

    .hero-title {
      margin: 0 0 1.5rem 0;
      font-size: clamp(1.45rem, 2.8vw, 2.2rem);
      font-weight: 700;
      letter-spacing: 0.01em;
      color: rgba(255, 255, 255, 0.95);
      text-align: center;
      text-shadow: 0 4px 14px rgba(0, 0, 0, 0.35);
    }

    .hero-logo img {
      width: 350px;
      height: auto;
      margin-bottom: 1rem;
    }

    .url-select,
    .frame-limit-select,
    .drop-zone {
      width: 100%;
      max-width: 300px;
      margin: 0.5rem auto;
      padding: 0.75rem;
      border-radius: 6px;
      font-size: 0.7rem;
      text-align: center;
    }

    .drop-zone {
      max-width: 500px;
      padding-top: 4rem;
      padding-bottom: 4rem;
    }

    .url-select {
      background-color: rgb(47, 47, 47);
      border: none;
      color: #fff;
      text-align: center;
      cursor: pointer;
      font-family: system-ui, sans-serif;
      font-size: 0.7rem;
      font-weight: 400;
      appearance: none;
      -webkit-appearance: none;
      text-align-last: center;
      -moz-text-align-last: center;
      display: block;
    }

    .url-form {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .url-row {
      width: 100%;
      max-width: 500px;
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 10px;
      margin: 0.5rem auto;
    }

    .url-row .url-select,
    .url-row .frame-limit-wrap {
      width: 100%;
      max-width: none;
      margin: 0;
    }

    .frame-limit-wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      border-radius: 6px;
      background-color: rgb(47, 47, 47);
      color: #fff;
      font-family: system-ui, sans-serif;
      font-size: 0.7rem;
      font-weight: 400;
      overflow: hidden;
    }

    .frame-limit-select {
      background-color: transparent;
      border: none;
      color: #fff;
      font-family: system-ui, sans-serif;
      font-size: 0.7rem;
      font-weight: 400;
      display: block;
      width: 100%;
      text-align: center;
      text-align-last: center;
      -moz-text-align-last: center;
      padding: 0.75rem;
      margin: 0;
      outline: none;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
    }

    .cache-all-button {
      width: 100%;
      max-width: 500px;
      margin: 0.5rem auto 0.25rem auto;
      padding: 0.75rem;
      border: none;
      border-radius: 6px;
      background-color: rgb(60, 60, 60);
      color: #fff;
      font-size: 0.7rem;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    .cache-all-progress {
      position: absolute;
      inset: 0;
      width: 0%;
      background: rgba(255, 255, 255, 0.18);
      transition: width 0.18s ease;
      pointer-events: none;
    }

    .cache-all-button.is-caching .cache-all-progress {
      background-image: linear-gradient(
        120deg,
        rgba(255, 255, 255, 0.12) 0%,
        rgba(255, 255, 255, 0.28) 35%,
        rgba(255, 255, 255, 0.12) 70%
      );
      background-size: 200% 100%;
      animation: cacheProgressSweep 1s linear infinite;
    }

    @keyframes cacheProgressSweep {
      from {
        background-position: 200% 0;
      }
      to {
        background-position: 0 0;
      }
    }

    .cache-all-label {
      position: relative;
      z-index: 1;
    }

    .cache-all-label-text {
      display: inline;
    }

    .cache-all-label-dots {
      display: inline-block;
      width: 1.6em;
      text-align: left;
    }

    .cache-all-button:hover {
      background-color: rgb(90, 90, 90);
    }

    .cache-all-button:disabled {
      opacity: 0.7;
      cursor: default;
    }

    .drop-zone {
      border: 1px dashed #666;
      color: rgb(89, 89, 89);
      background-color: rgb(47, 47, 47);
      cursor: pointer;
    }

    .drop-zone.dragover {
      border: 1px dashed #aaa;
      color: rgb(170, 170, 170);
    }

    @media (min-width: 600px) {
      .url-select,
      .frame-limit-wrap,
      .frame-limit-select,
      .drop-zone {
        font-size: 0.77rem;
      }

      .cache-all-button {
        font-size: 0.77rem;
      }
    }

    .hidden {
      display: none;
    }

    .controls {
      position: relative;
      display: grid;
      grid-template-columns: auto minmax(0, 1fr) auto;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background: rgba(28, 28, 28, 0.7);
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(8px);
      z-index: 2;
      width: 100%;
      pointer-events: auto;
    }

    .controls .controls-left,
    .controls .controls-right {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .controls .controls-right {
      min-width: 0;
      flex-wrap: wrap;
      justify-content: flex-end;
      row-gap: 8px;
    }

    .controls .controls-right > * {
      flex-shrink: 0;
    }

    .controls .play-toggle {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1em;
      background: rgba(255, 255, 255, 0.15);
    }

    .controls .caching-percent {
      display: none;
      min-width: 44px;
      font-size: 0.8em;
      color: rgba(255, 255, 255, 0.8);
      font-variant-numeric: tabular-nums;
      text-align: left;
    }

    .controls .caching-percent.is-visible {
      display: inline-block;
    }

    .controls .play-toggle.is-loading {
      cursor: default;
      opacity: 0.7;
    }

    .controls .play-toggle .loading-spinner {
      display: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.4);
      border-top-color: #fff;
      animation: spin 0.9s linear infinite;
    }

    .controls .play-toggle.is-loading .play-icon {
      display: none;
    }

    .controls .play-toggle.is-loading .loading-spinner {
      display: inline-block;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .controls .play-toggle .play-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      font-size: 1.1em;
      letter-spacing: -2px;
    }

    .controls .progress-wrap {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 8px;
      width: 100%;
      min-width: 0;
    }

    .controls .fov-wrap {
      display: none;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.08);
    }

    .controls .fov-label {
      font-size: 0.8em;
      color: rgba(255, 255, 255, 0.7);
      white-space: nowrap;
    }

    .controls .fov-value {
      min-width: 38px;
      text-align: right;
      font-variant-numeric: tabular-nums;
      color: rgba(255, 255, 255, 0.85);
      font-size: 0.85em;
    }

    .controls .fov-slider {
      width: 90px;
      accent-color: #fff;
    }

    .controls .time {
      font-size: 0.82em;
      color: rgba(255, 255, 255, 0.7);
      min-width: 44px;
      text-align: center;
    }

    .controls .progress {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.15);
      outline: none;
    }

    .controls .progress::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.15);
      cursor: pointer;
    }

    .controls .progress::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #fff;
      border: none;
      cursor: pointer;
    }

    .viewer-window {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      pointer-events: none;
      padding: clamp(12px, 2vw, 28px);
    }

    .viewer-window .viewer-stack {
      width: min(92vw, 1220px, calc(min(86vh, 760px) * 16 / 9));
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      margin: auto;
      pointer-events: auto;
    }

    .viewer-window .window-frame {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      height: auto;
      background: #111;
      border: 3px solid rgba(180, 180, 180, 0.75);
      border-radius: clamp(16px, 2.2vw, 28px);
      overflow: hidden;
      box-shadow: 0 30px 80px rgba(0, 0, 0, 0.55);
      pointer-events: auto;
    }

    .controls-right #VRButton {
      position: static !important;
      left: auto !important;
      bottom: auto !important;
      width: auto !important;
      min-width: 80px;
      padding: 0 6px !important;
      border: none !important;
      border-radius: 10px !important;
      background-color: rgba(255, 255, 255, 0.12) !important;
      opacity: 1 !important;
      font-size: 0 !important;
      line-height: 1;
      height: 30px !important;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-shadow: none !important;
      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;
    }

    .controls-right #VRButton:hover {
      background-color: rgb(90, 90, 90) !important;
    }

    .controls-right #VRButton::before {
      content: 'VR';
      font-size: 0.95rem;
      font-weight: 600;
      line-height: 1;
      letter-spacing: 0.02em;
    }

    .controls button {
      background-color: rgba(255, 255, 255, 0.12);
      border: none;
      color: #fff;
      padding: 6px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9em;
    }

    .controls button:hover {
      background-color: rgb(90, 90, 90);
    }

    .controls select {
      background: rgba(255, 255, 255, 0.12);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 0.85em;
      cursor: pointer;
    }

    .controls .controls-right > .speed-select,
    .controls .controls-right > .import-button,
    .controls .controls-right > .reset-button,
    .controls .controls-right > #VRButton {
      min-width: 80px;
      height: 30px;
      padding: 0 6px;
      border-radius: 10px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      text-align: center;
      font-size: 0.74em;
    }

    .controls .controls-right > .speed-select {
      width: 80px;
      text-align: center;
      text-align-last: center;
      -moz-text-align-last: center;
    }

    .frame-indicator {
      font-size: 0.85em;
      color: rgba(255, 255, 255, 0.65);
      padding: 0 6px;
      white-space: nowrap;
    }

    .frame-indicator-progress {
      display: none;
      min-width: 52px;
      text-align: right;
      padding-right: 0;
    }

    @media (max-width: 1100px) {
      .controls {
        grid-template-columns: auto minmax(0, 1fr);
        grid-template-areas:
          'left progress'
          'right right';
        gap: 8px 10px;
        padding: 8px 10px;
      }

      .controls .controls-left {
        grid-area: left;
      }

      .controls .progress-wrap {
        grid-area: progress;
      }

      .controls .controls-right {
        grid-area: right;
      }

      .controls .controls-left {
        justify-self: start;
      }

      .controls .controls-right {
        width: 100%;
        flex-wrap: wrap;
        justify-content: space-evenly;
        gap: 10px 12px;
      }

      .controls .progress-wrap {
        width: 100%;
        min-width: 0;
        grid-template-columns: auto minmax(0, 1fr) auto auto;
      }

      .controls .frame-indicator-progress {
        display: inline-block;
        font-size: 0.82em;
      }

      .controls .frame-indicator-actions {
        display: none;
      }

      .controls .time {
        min-width: 54px;
      }

      .controls .fov-slider {
        width: min(120px, 22vw);
      }
    }

    @media (max-width: 760px) {
      .drop-container {
        padding-left: 12px;
        padding-right: 12px;
      }

      .url-row,
      .cache-all-button,
      .drop-zone {
        max-width: 100%;
      }

      .controls {
        grid-template-columns: auto minmax(0, 1fr);
        grid-template-areas:
          'left progress'
          'right right';
        border-radius: 12px;
        padding: 8px;
        gap: 6px;
      }

      .controls .controls-left {
        justify-content: flex-start;
      }

      .controls .play-toggle {
        width: 36px;
        height: 36px;
      }

      .controls .controls-right {
        width: 100%;
        display: flex;
        flex-wrap: nowrap;
        justify-content: stretch;
        gap: 6px;
      }

      .controls button,
      .controls select {
        font-size: 0.82em;
        padding: 5px 10px;
      }

      .controls .controls-right > .speed-select,
      .controls .controls-right > .import-button,
      .controls .controls-right > .reset-button,
      .controls .controls-right > #VRButton {
        flex: 1 1 0;
        min-width: 0;
        width: 100%;
        height: 28px;
        padding: 0 6px;
      }

      .controls .controls-right > #VRButton {
        min-width: 0 !important;
        width: 100% !important;
        height: 28px !important;
        padding: 0 6px !important;
      }

      .controls .progress-wrap {
        grid-template-columns: max-content minmax(0, 1fr) max-content max-content;
        gap: 4px;
      }

      .controls .frame-indicator-progress {
        min-width: 0;
        padding: 0;
        font-size: 0.74em;
      }

      .controls .fov-wrap {
        flex: 1 1 100%;
        justify-content: center;
        gap: 6px;
        padding: 4px 6px;
      }

      .controls .fov-slider {
        width: min(140px, 42vw);
      }

      .controls .time {
        min-width: 0;
        font-size: 0.76em;
      }
    }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "./vendor/three/build/three.module.js",
        "three/addons/": "./vendor/three/examples/jsm/",
        "@sparkjsdev/spark": "./dist/spark.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from "three";
    import { SplatMesh, SparkControls, SparkRenderer, VRButton } from "@sparkjsdev/spark";

    const sparkCanvasEl = document.querySelector(".spark-canvas");
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.set(0, 0, 0);
    const renderer = new THREE.WebGLRenderer({canvas: sparkCanvasEl});
    const frameEl = document.querySelector('.window-frame');
    const width = frameEl.clientWidth;
    const height = frameEl.clientHeight;
    renderer.setSize(width, height, false);

    // VR mode support
    const localFrame = new THREE.Group();
    scene.add(localFrame);

    const spark = new SparkRenderer({ renderer, maxStdDev: Math.sqrt(5) });
    localFrame.add(spark);
    scene.add(camera);

    const vrButton = VRButton.createButton(renderer, {
      optionalFeatures: ["hand-tracking"],
    });

    const DEFAULT_WIN_W = 2.112, DEFAULT_WIN_H = 1.188;   // window opening in world meters (+10%)
    let winW = DEFAULT_WIN_W;
    let winH = DEFAULT_WIN_H;
    const VR_TARGET_VISIBLE_AREA = 0.8;
    const VR_TARGET_VISIBLE_AXIS = Math.sqrt(VR_TARGET_VISIBLE_AREA);
    const VR_MIN_WIN_W = 0.9;
    const VR_MAX_WIN_W = 3.0;
    const VR_MIN_WIN_H = 0.5;
    const VR_MAX_WIN_H = 1.8;
    // ── VR Window Frame (mask) ──
    // A large dark-gray plane with a transparent rounded-rect hole in the center.
    // Outside the hole = opaque dark matte (blocks rear texture), inside the hole = transparent (shows 3DGS).
    const MASK_CANVAS_W = 3200, MASK_CANVAS_H = 2000;
    const MASK_PLANE_W = 10.0, MASK_PLANE_H = 6.25;  // plane world size (matches canvas aspect 1600:1000)

    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = MASK_CANVAS_W;
    maskCanvas.height = MASK_CANVAS_H;
    const maskCtx = maskCanvas.getContext('2d');

    const maskTexture = new THREE.CanvasTexture(maskCanvas);
    maskTexture.minFilter = THREE.LinearFilter;
    maskTexture.magFilter = THREE.LinearFilter;
    maskTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    maskTexture.generateMipmaps = false;
    const maskMaterial = new THREE.MeshBasicMaterial({
      map: maskTexture,
      transparent: true,
      side: THREE.DoubleSide,
      depthTest: false,
      depthWrite: false,
    });
    const vrWindowMask = new THREE.Mesh(
      new THREE.PlaneGeometry(MASK_PLANE_W, MASK_PLANE_H),
      maskMaterial,
    );
    vrWindowMask.renderOrder = 9998;
    vrWindowMask.frustumCulled = false;
    vrWindowMask.visible = false;

    // Container group for the window
    const vrFrameGroup = new THREE.Group();
    vrFrameGroup.visible = false;
    scene.add(vrFrameGroup);

    const vrBounds = new THREE.Box3();
    const vrSplatCenterWorld = new THREE.Vector3();
    const vrSplatCenterInFrame = new THREE.Vector3();
    const vrFrameRight = new THREE.Vector3();
    const vrFrameUp = new THREE.Vector3();
    const vrCorner = new THREE.Vector3();

    const FRAME_DIST = 2.0;
    vrWindowMask.position.set(0, 0, -FRAME_DIST);
    vrFrameGroup.add(vrWindowMask);

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    function drawVrWindowMask(openW, openH) {
      winW = Math.max(VR_MIN_WIN_W, Math.min(VR_MAX_WIN_W, Number(openW) || DEFAULT_WIN_W));
      winH = Math.max(VR_MIN_WIN_H, Math.min(VR_MAX_WIN_H, Number(openH) || DEFAULT_WIN_H));

      const holePixW = (winW / MASK_PLANE_W) * MASK_CANVAS_W;
      const holePixH = (winH / MASK_PLANE_H) * MASK_CANVAS_H;
      const holeX = (MASK_CANVAS_W - holePixW) / 2;
      const holeY = (MASK_CANVAS_H - holePixH) / 2;
      const holeRad = Math.max(20, Math.min(120, Math.min(holePixW, holePixH) * 0.12));

      // 1) Fill canvas with opaque dark matte to fully block rear texture bleed in VR
      maskCtx.clearRect(0, 0, MASK_CANVAS_W, MASK_CANVAS_H);
      maskCtx.fillStyle = 'rgba(16, 16, 18, 1)';
      maskCtx.fillRect(0, 0, MASK_CANVAS_W, MASK_CANVAS_H);

      // 2) Cut out a transparent rounded-rect hole in the center
      maskCtx.globalCompositeOperation = 'destination-out';
      maskCtx.fillStyle = '#000';
      roundRect(maskCtx, holeX, holeY, holePixW, holePixH, holeRad);
      maskCtx.fill();
      maskCtx.globalCompositeOperation = 'source-over';

      // 3) Draw a subtle border around the window opening
      maskCtx.strokeStyle = 'rgba(180, 180, 180, 0.6)';
      maskCtx.lineWidth = 3 * (MASK_CANVAS_W / 1600);
      roundRect(maskCtx, holeX, holeY, holePixW, holePixH, holeRad);
      maskCtx.stroke();

      // 4) Outer shadow / vignette around the hole
      maskCtx.shadowColor = 'rgba(0, 0, 0, 0.3)';
      maskCtx.shadowBlur = 30 * (MASK_CANVAS_W / 1600);
      maskCtx.strokeStyle = 'rgba(0,0,0,0)';
      maskCtx.lineWidth = 1;
      roundRect(maskCtx, holeX - 1, holeY - 1, holePixW + 2, holePixH + 2, holeRad);
      maskCtx.stroke();
      maskCtx.shadowBlur = 0;

      maskTexture.needsUpdate = true;

    }

    drawVrWindowMask(DEFAULT_WIN_W, DEFAULT_WIN_H);

    function centerSplatInVrWindow() {
      if (!loadedSplat) return;
      vrBounds.setFromObject(loadedSplat);
      if (vrBounds.isEmpty()) return;

      vrBounds.getCenter(vrSplatCenterWorld);
      vrSplatCenterInFrame.copy(vrSplatCenterWorld);
      vrFrameGroup.worldToLocal(vrSplatCenterInFrame);

      const dx = vrSplatCenterInFrame.x;
      const dy = vrSplatCenterInFrame.y;
      if (Math.abs(dx) + Math.abs(dy) < 1e-6) return;

      vrFrameRight.set(1, 0, 0).applyQuaternion(vrFrameGroup.quaternion);
      vrFrameUp.set(0, 1, 0).applyQuaternion(vrFrameGroup.quaternion);
      localFrame.position.addScaledVector(vrFrameRight, -dx);
      localFrame.position.addScaledVector(vrFrameUp, -dy);
    }

    function fitVrWindowToSplat() {
      if (!loadedSplat) {
        drawVrWindowMask(DEFAULT_WIN_W, DEFAULT_WIN_H);
        return;
      }

      centerSplatInVrWindow();

      vrBounds.setFromObject(loadedSplat);
      if (vrBounds.isEmpty()) {
        drawVrWindowMask(DEFAULT_WIN_W, DEFAULT_WIN_H);
        return;
      }

      const xs = [vrBounds.min.x, vrBounds.max.x];
      const ys = [vrBounds.min.y, vrBounds.max.y];
      const zs = [vrBounds.min.z, vrBounds.max.z];

      let minX = Number.POSITIVE_INFINITY;
      let maxX = Number.NEGATIVE_INFINITY;
      let minY = Number.POSITIVE_INFINITY;
      let maxY = Number.NEGATIVE_INFINITY;

      for (const x of xs) {
        for (const y of ys) {
          for (const z of zs) {
            vrCorner.set(x, y, z);
            vrFrameGroup.worldToLocal(vrCorner);
            minX = Math.min(minX, vrCorner.x);
            maxX = Math.max(maxX, vrCorner.x);
            minY = Math.min(minY, vrCorner.y);
            maxY = Math.max(maxY, vrCorner.y);
          }
        }
      }

      const spanX = Math.max(1e-4, maxX - minX);
      const spanY = Math.max(1e-4, maxY - minY);
      const desiredW = spanX * VR_TARGET_VISIBLE_AXIS;
      const desiredH = spanY * VR_TARGET_VISIBLE_AXIS;
      drawVrWindowMask(desiredW, desiredH);

      // Recenter once more after changing aperture size.
      centerSplatInVrWindow();
    }

    let shouldResetViewAfterVrExit = false;
    let vrFrameInitialized = false;
    let pendingVrRefit = false;
    let xrPlaybackClockInitialized = false;
    let xrPlaybackLastTimestamp = 0;
    let xrPlaybackElapsedMs = 0;

    function resetXrPlaybackClock() {
      xrPlaybackClockInitialized = false;
      xrPlaybackLastTimestamp = 0;
      xrPlaybackElapsedMs = 0;
    }

    renderer.xr.addEventListener('sessionstart', () => {
      if (vrButton) {
        vrButton.setAttribute('aria-label', 'Exit VR');
        vrButton.setAttribute('title', 'Exit VR');
      }
      vrFrameGroup.visible = true;
      vrWindowMask.visible = true;
      vrFrameInitialized = false;
      vrFrameGroup.position.set(0, 0, 0);
      vrFrameGroup.rotation.set(0, 0, 0);
      localFrame.position.set(0, 0, 0);
      localFrame.rotation.set(0, 0, 0);
      localFrame.scale.set(1, 1, 1);
      drawVrWindowMask(DEFAULT_WIN_W, DEFAULT_WIN_H);
      pendingVrRefit = true;
      stopPlayback();
      resetXrPlaybackClock();
    });
    renderer.xr.addEventListener('sessionend', () => {
      if (vrButton) {
        vrButton.setAttribute('aria-label', 'Enter VR');
        vrButton.setAttribute('title', 'Enter VR');
      }
      vrFrameGroup.visible = false;
      vrWindowMask.visible = false;
      localFrame.position.set(0, 0, 0);
      localFrame.rotation.set(0, 0, 0);
      localFrame.scale.set(1, 1, 1);
      vrFrameInitialized = false;
      pendingVrRefit = false;
      resetXrPlaybackClock();
      if (isPlaying) {
        scheduleNextPlaybackTick();
      }
      resetViewState();
      shouldResetViewAfterVrExit = true;
    });

    const controls = new SparkControls({ canvas: sparkCanvasEl });
    controls.fpsMovement.rotateSpeed = 0.6;
    controls.fpsMovement.moveSpeed = 0.8;
    controls.fpsMovement.keycodeMoveMapping = {
      KeyW: new THREE.Vector3(0, 0, -1),
      KeyS: new THREE.Vector3(0, 0, 1),
      KeyA: new THREE.Vector3(-1, 0, 0),
      KeyD: new THREE.Vector3(1, 0, 0),
      KeyR: new THREE.Vector3(0, 1, 0),
      KeyF: new THREE.Vector3(0, -1, 0),
    };
    controls.fpsMovement.keycodeRotateMapping = {};

    const orbitTarget = new THREE.Vector3(0, 0, 0);
    let orbitYaw = 0;
    let orbitPitch = 0;
    let orbitDistance = 1.5;
    const orbitSpeed = 0.005;
    const lastCameraPos = new THREE.Vector3().copy(camera.position);
    let initialOrbitTarget = new THREE.Vector3(0, 0, 0);
    let initialOrbitYaw = 0;
    let initialOrbitPitch = 0;
    let initialOrbitDistance = 1.5;
    let hasInitialOrbit = false;
    const orbitKeyState = {
      ArrowLeft: false,
      ArrowRight: false,
      ArrowUp: false,
      ArrowDown: false,
    };

    function applyOrbit() {
      const cosPitch = Math.cos(orbitPitch);
      const sinPitch = Math.sin(orbitPitch);
      const cosYaw = Math.cos(orbitYaw);
      const sinYaw = Math.sin(orbitYaw);
      const offset = new THREE.Vector3(
        orbitDistance * sinYaw * cosPitch,
        orbitDistance * sinPitch,
        orbitDistance * cosYaw * cosPitch,
      );
      camera.position.copy(orbitTarget).add(offset);
      camera.lookAt(orbitTarget);
    }

    function syncOrbitFromCamera() {
      const offset = camera.position.clone().sub(orbitTarget);
      orbitDistance = Math.max(0.1, offset.length());
      if (orbitDistance <= 0) {
        orbitYaw = 0;
        orbitPitch = 0;
        return;
      }
      orbitYaw = Math.atan2(offset.x, offset.z);
      orbitPitch = Math.asin(THREE.MathUtils.clamp(offset.y / orbitDistance, -1, 1));
    }

    function resetView() {
      if (!hasInitialOrbit) return;
      orbitTarget.copy(initialOrbitTarget);
      orbitYaw = initialOrbitYaw;
      orbitPitch = initialOrbitPitch;
      orbitDistance = initialOrbitDistance;
      applyOrbit();
      lastCameraPos.copy(camera.position);
    }

    function resetViewState() {
      resetView();
      updateFov(35);
    }

    window.addEventListener('keydown', (event) => {
      if (event.code in orbitKeyState) {
        orbitKeyState[event.code] = true;
        event.preventDefault();
      }
    });

    window.addEventListener('keyup', (event) => {
      if (event.code in orbitKeyState) {
        orbitKeyState[event.code] = false;
        event.preventDefault();
      }
    });

    function resize() {
      const width = frameEl.clientWidth;
      const height = frameEl.clientHeight;

      const canvas = renderer.domElement;
      const needResize = canvas.width !== width || canvas.height !== height;

      if (needResize) {
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }
    }

    const resizeObserver = new ResizeObserver(() => {
      setTimeout(function () { resize(); }, 50);
    });
    resizeObserver.observe(frameEl);

    const SHORT_MAX_FRAMES = 16;
    const MEDIUM_MAX_FRAMES = 32;
    const FRAME_LIMIT_MODE_SHORT = 'short';
    const FRAME_LIMIT_MODE_MEDIUM = 'medium';
    const FRAME_LIMIT_MODE_LONG = 'long';
    const IS_IOS_DEVICE = /iPad|iPhone|iPod/.test(navigator.userAgent)
      || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const XR_PRELOAD_AHEAD_FRAMES = 0;
    const XR_MAX_RESIDENT_MESHES = Number.POSITIVE_INFINITY;
    const XR_WARMUP_FRAMES = Number.POSITIVE_INFINITY;
    const IOS_PRELOAD_AHEAD_FRAMES = 2;
    const IOS_MAX_RESIDENT_MESHES = 6;
    const DESKTOP_PRELOAD_AHEAD_FRAMES = 6;
    const DESKTOP_MAX_RESIDENT_MESHES = 18;
    const IOS_WARMUP_BYTE_CONCURRENCY = 2;
    const DESKTOP_WARMUP_BYTE_CONCURRENCY = 2;
    const IOS_CACHE_SCENE_CONCURRENCY = 2;
    const DESKTOP_CACHE_SCENE_CONCURRENCY = 2;
    const IOS_CACHE_FRAME_BYTE_CONCURRENCY = 2;
    const DESKTOP_CACHE_FRAME_BYTE_CONCURRENCY = 2;
    let maxFramesMode = FRAME_LIMIT_MODE_SHORT;
    let maxFramesToLoad = SHORT_MAX_FRAMES;

    function getRuntimeMemoryPolicy() {
      if (renderer.xr.isPresenting) {
        return {
          preloadAheadFrames: XR_PRELOAD_AHEAD_FRAMES,
          maxResidentMeshes: XR_MAX_RESIDENT_MESHES,
          releaseBytesAfterMesh: true,
          warmupFrameCount: XR_WARMUP_FRAMES,
        };
      }
      if (IS_IOS_DEVICE) {
        return {
          preloadAheadFrames: DESKTOP_PRELOAD_AHEAD_FRAMES,
          maxResidentMeshes: (
            maxFramesMode === FRAME_LIMIT_MODE_LONG
            || maxFramesMode === FRAME_LIMIT_MODE_MEDIUM
          )
            ? Number.POSITIVE_INFINITY
            : DESKTOP_MAX_RESIDENT_MESHES,
          releaseBytesAfterMesh: false,
          warmupFrameCount: Number.POSITIVE_INFINITY,
        };
      }
      return {
        preloadAheadFrames: DESKTOP_PRELOAD_AHEAD_FRAMES,
        maxResidentMeshes: (
          maxFramesMode === FRAME_LIMIT_MODE_LONG
          || maxFramesMode === FRAME_LIMIT_MODE_MEDIUM
        )
          ? Number.POSITIVE_INFINITY
          : DESKTOP_MAX_RESIDENT_MESHES,
        releaseBytesAfterMesh: false,
        warmupFrameCount: Number.POSITIVE_INFINITY,
      };
    }

    function parseFrameLimitMode(value) {
      const raw = String(value ?? '').trim().toLowerCase();
      if (raw === FRAME_LIMIT_MODE_MEDIUM || raw === '32') {
        return FRAME_LIMIT_MODE_MEDIUM;
      }
      if (raw === FRAME_LIMIT_MODE_LONG || raw === 'all' || raw === 'infinity') {
        return FRAME_LIMIT_MODE_LONG;
      }
      const parsed = Number.parseInt(raw, 10);
      if (Number.isFinite(parsed) && parsed > MEDIUM_MAX_FRAMES) {
        return FRAME_LIMIT_MODE_LONG;
      }
      if (parsed === MEDIUM_MAX_FRAMES) {
        return FRAME_LIMIT_MODE_MEDIUM;
      }
      return FRAME_LIMIT_MODE_SHORT;
    }

    function applyFrameLimitMode(mode) {
      if (mode === FRAME_LIMIT_MODE_LONG) {
        maxFramesMode = FRAME_LIMIT_MODE_LONG;
        maxFramesToLoad = Number.POSITIVE_INFINITY;
        return;
      }
      if (mode === FRAME_LIMIT_MODE_MEDIUM) {
        maxFramesMode = FRAME_LIMIT_MODE_MEDIUM;
        maxFramesToLoad = MEDIUM_MAX_FRAMES;
        return;
      }
      maxFramesMode = FRAME_LIMIT_MODE_SHORT;
      maxFramesToLoad = SHORT_MAX_FRAMES;
    }

    function limitFrames(list) {
      return list.slice(0, maxFramesToLoad);
    }

    let params = new URLSearchParams(document.location.search);
    const paramFrameLimit = params.get('n') ?? params.get('maxFrames');
    if (paramFrameLimit != null) {
      applyFrameLimitMode(parseFrameLimitMode(paramFrameLimit));
    }

    let frames = [];
    let currentIndex = 0;
    let isPlaying = false;
    let fps = 30;
    let speedMultiplier = 1;
    let isLoadingFrame = false;
    let playbackTimer = null;
    let isCaching = false;
    let cachingTaskId = 0;
    let cachingProgress = 0;

    const playBtn = document.querySelector('.play-button');
    const playIcon = document.querySelector('.play-icon');
    const cachingPercentEl = document.querySelector('.caching-percent');
    const frameIndicatorEls = document.querySelectorAll('.frame-indicator');
    const progressEl = document.querySelector('.progress');
    const timeCurrentEl = document.querySelector('.time-current');
    const timeTotalEl = document.querySelector('.time-total');
    const speedSelect = document.querySelector('.speed-select');
    const resetBtn = document.querySelector('.reset-button');
    const importBtn = document.querySelector('.import-button');
    const frameLimitSelectEl = document.querySelector('.frame-limit-select');
    const fovSlider = document.querySelector('.fov-slider');
    const fovValue = document.querySelector('.fov-value');
    const controlsRightEl = document.querySelector('.controls-right');

    if (frameLimitSelectEl) {
      frameLimitSelectEl.value = maxFramesMode;
      frameLimitSelectEl.addEventListener('change', () => {
        applyFrameLimitMode(frameLimitSelectEl.value);
        frameLimitSelectEl.value = maxFramesMode;
      });
    }

    if (vrButton) {
      vrButton.style.zIndex = '3';
      vrButton.setAttribute('aria-label', 'Enter VR');
      vrButton.setAttribute('title', 'Enter VR');
      if (controlsRightEl) {
        controlsRightEl.appendChild(vrButton);
      } else {
        document.body.appendChild(vrButton);
      }
    }

    function updateFov(value) {
      const nextFov = Math.min(90, Math.max(10, Number(value)));
      camera.fov = nextFov;
      camera.updateProjectionMatrix();
      fovValue.textContent = `${Math.round(nextFov)}°`;
      fovSlider.value = String(nextFov);
    }

    function formatTime(seconds) {
      if (!Number.isFinite(seconds) || seconds < 0) return '00:00';
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }

    function extractFrameSequence(name) {
      if (typeof name !== 'string') return null;
      const match = name.match(/(\d+)(?!.*\d)/);
      if (!match) return null;
      const parsed = Number(match[1]);
      return Number.isFinite(parsed) ? parsed : null;
    }

    function getFrameTimeUnits(index, frameList = frames) {
      const frame = frameList[index];
      if (!frame) return index;
      if (Number.isFinite(frame.timeUnits)) {
        return frame.timeUnits;
      }
      const parsed = extractFrameSequence(frame.name);
      if (Number.isFinite(parsed)) {
        frame.timeUnits = parsed;
        return parsed;
      }
      frame.timeUnits = index;
      return frame.timeUnits;
    }

    function getTypicalFrameStepUnits(frameList = frames) {
      if (!Array.isArray(frameList) || frameList.length < 2) return 1;
      let minPositive = Number.POSITIVE_INFINITY;
      for (let i = 1; i < frameList.length; i += 1) {
        const prev = getFrameTimeUnits(i - 1, frameList);
        const curr = getFrameTimeUnits(i, frameList);
        const delta = curr - prev;
        if (delta > 0 && delta < minPositive) {
          minPositive = delta;
        }
      }
      return Number.isFinite(minPositive) ? minPositive : 1;
    }

    function getNextFrameDelayMs(index, frameList = frames) {
      const total = frameList.length;
      if (total <= 1) {
        return 1000 / (fps * Math.max(speedMultiplier, 0.001));
      }

      const currentUnits = getFrameTimeUnits(index, frameList);
      const nextIndex = (index + 1) % total;
      const nextUnits = getFrameTimeUnits(nextIndex, frameList);

      let deltaUnits = nextUnits - currentUnits;
      if (deltaUnits <= 0) {
        const firstUnits = getFrameTimeUnits(0, frameList);
        const lastUnits = getFrameTimeUnits(total - 1, frameList);
        const typicalStep = getTypicalFrameStepUnits(frameList);
        const cycleUnits = Math.max(typicalStep, (lastUnits - firstUnits) + typicalStep);
        deltaUnits += cycleUnits;
      }

      const safeSpeed = Math.max(speedMultiplier, 0.001);
      const delayMs = (1000 * deltaUnits) / (fps * safeSpeed);
      return Math.max(1, delayMs);
    }

    function updateIndicator() {
      const total = frames.length || 0;
      const idx = total ? (currentIndex + 1) : 0;
      for (const el of frameIndicatorEls) {
        el.textContent = `${idx}/${total}`;
      }
    }

    function updateProgress() {
      const total = frames.length || 0;
      progressEl.max = total > 0 ? String(total - 1) : '0';
      progressEl.value = total > 0 ? String(currentIndex) : '0';
      const safeFps = Math.max(fps, 0.001);
      const firstUnits = total > 0 ? getFrameTimeUnits(0, frames) : 0;
      const lastUnits = total > 0 ? getFrameTimeUnits(total - 1, frames) : 0;
      const currentUnits = total > 0 ? getFrameTimeUnits(currentIndex, frames) : 0;
      const totalSeconds = total > 0 ? Math.max(0, (lastUnits - firstUnits) / safeFps) : 0;
      const currentSeconds = total > 0 ? Math.max(0, (currentUnits - firstUnits) / safeFps) : 0;
      timeCurrentEl.textContent = formatTime(currentSeconds);
      timeTotalEl.textContent = formatTime(totalSeconds);
    }

    function showViewerInterface() {
      document.querySelector('.container').classList.add('hidden');
      document.querySelector('.canvas-container').classList.remove('invisible');
    }

    function showImportInterface() {
      setPlaying(false);
      document.querySelector('.canvas-container').classList.add('invisible');
      document.querySelector('.container').classList.remove('hidden');
      if (urlDirSelectEl) {
        urlDirSelectEl.value = '';
      }
      selectedSceneDirectory = '';
      setCacheButtonState({
        label: cacheButtonIdleLabel,
        progress: 0,
        disabled: false,
      });
    }

    async function showFrame(index) {
      if (!frames.length || isLoadingFrame) return;
      isLoadingFrame = true;
      currentIndex = (index + frames.length) % frames.length;
      const frame = frames[currentIndex];

      try {
        if (!frame) return;
        const mesh = await ensureFrameMesh(currentIndex);
        if (!mesh) return;

        if (loadedSplat && loadedSplat !== mesh) {
          loadedSplat.visible = false;
        }
        mesh.visible = true;
        loadedSplat = mesh;

        if (!hasInitialOrbit) {
          syncOrbitFromCamera();
          initialOrbitTarget = orbitTarget.clone();
          initialOrbitYaw = orbitYaw;
          initialOrbitPitch = orbitPitch;
          initialOrbitDistance = orbitDistance;
          hasInitialOrbit = true;
          lastCameraPos.copy(camera.position);
        }
      } catch (error) {
        if (frame) {
          frame.meshPromise = null;
        }
        throw error;
      } finally {
        isLoadingFrame = false;
      }

      updateIndicator();
      updateProgress();
      trimFrameMeshes(currentIndex, frames);
      preloadFrames(currentIndex, frames);

      if (renderer.xr.isPresenting && vrFrameInitialized && pendingVrRefit) {
        fitVrWindowToSplat();
        pendingVrRefit = false;
      }
    }

    async function nextFrame() { await showFrame(currentIndex + 1); }

    function scheduleNextPlaybackTick() {
      if (renderer.xr.isPresenting) return;
      if (!isPlaying || playbackTimer || !frames.length) return;
      const delayMs = getNextFrameDelayMs(currentIndex, frames);
      playbackTimer = setTimeout(async () => {
        playbackTimer = null;
        if (!isPlaying || !frames.length) return;
        try {
          if (!isLoadingFrame) {
            await nextFrame();
          }
        } catch (error) {
          console.warn('Frame playback failed, will retry on next tick:', error);
        }
        scheduleNextPlaybackTick();
      }, delayMs);
    }

    function startPlayback() {
      scheduleNextPlaybackTick();
    }

    function stopPlayback() {
      if (playbackTimer) {
        clearTimeout(playbackTimer);
        playbackTimer = null;
      }
    }

    function setPlaying(val) {
      isPlaying = val;
      playIcon.textContent = isPlaying ? '❚❚' : '▶';
      playBtn.setAttribute('aria-label', isPlaying ? 'Pause' : 'Play');
      if (isPlaying) {
        if (renderer.xr.isPresenting) {
          resetXrPlaybackClock();
          stopPlayback();
          return;
        }
        startPlayback();
      } else {
        stopPlayback();
        resetXrPlaybackClock();
      }
    }

    function setCaching(val) {
      isCaching = val;
      playBtn.classList.toggle('is-loading', isCaching);
      playBtn.disabled = isCaching;
      if (!isCaching) {
        cachingProgress = 0;
      }
      if (cachingPercentEl) {
        cachingPercentEl.classList.toggle('is-visible', isCaching);
        cachingPercentEl.textContent = `${Math.round(cachingProgress)}%`;
      }
      if (isCaching) {
        setPlaying(false);
      }
    }

    function setCachingProgress(value) {
      cachingProgress = Math.max(0, Math.min(100, Number(value) || 0));
      if (cachingPercentEl) {
        cachingPercentEl.textContent = `${Math.round(cachingProgress)}%`;
      }
    }

    function hasMissingFrameMeshes(frameList = frames) {
      if (!Array.isArray(frameList) || frameList.length === 0) return false;
      return frameList.some(frame => !frame?.mesh);
    }

    function cancelCachingTask() {
      cachingTaskId += 1;
      setCaching(false);
    }

    async function runIndexTasksWithConcurrency(totalCount, maxConcurrency, runTask, onProgress) {
      if (!Number.isFinite(totalCount) || totalCount <= 0) return;
      const safeTotal = Math.floor(totalCount);
      const safeConcurrency = Math.max(1, Math.min(safeTotal, Math.floor(maxConcurrency) || 1));
      let nextIndex = 0;
      let completed = 0;

      const worker = async () => {
        while (true) {
          const index = nextIndex;
          nextIndex += 1;
          if (index >= safeTotal) return;
          await runTask(index);
          completed += 1;
          if (typeof onProgress === 'function') {
            onProgress(completed, safeTotal, index);
          }
        }
      };

      const workers = Array.from({ length: safeConcurrency }, () => worker());
      await Promise.all(workers);
    }

    async function warmupPlaybackAssets(frameList = frames) {
      if (!Array.isArray(frameList) || frameList.length === 0) return true;

      const { maxResidentMeshes, warmupFrameCount, preloadAheadFrames } = getRuntimeMemoryPolicy();
      const canKeepAllMeshesResident = Number.isFinite(maxResidentMeshes)
        && frameList.length <= maxResidentMeshes;
      const shouldWarmupMeshes = renderer.xr.isPresenting
        || !Number.isFinite(maxResidentMeshes)
        || canKeepAllMeshesResident;
      const defaultWarmupCount = shouldWarmupMeshes
        ? frameList.length
        : Math.min(frameList.length, Math.max(1, preloadAheadFrames + 1));
      const targetWarmupCount = Number.isFinite(warmupFrameCount)
        ? Math.max(1, Math.min(defaultWarmupCount, warmupFrameCount))
        : defaultWarmupCount;
      const warmupConcurrency = shouldWarmupMeshes
        ? 1
        : (IS_IOS_DEVICE ? IOS_WARMUP_BYTE_CONCURRENCY : DESKTOP_WARMUP_BYTE_CONCURRENCY);
      const cancellationError = new Error('Warmup cancelled');
      cancellationError.name = 'WarmupCancelledError';

      if (shouldWarmupMeshes && !hasMissingFrameMeshes(frameList)) {
        return true;
      }

      const taskId = ++cachingTaskId;
      setCaching(true);
      setCachingProgress(0);

      try {
        await runIndexTasksWithConcurrency(
          targetWarmupCount,
          warmupConcurrency,
          async (i) => {
            if (taskId !== cachingTaskId) throw cancellationError;
            if (shouldWarmupMeshes) {
              await ensureFrameMesh(i, frameList);
            } else {
              await ensureFrameBytes(i, frameList);
            }
            if (taskId !== cachingTaskId) throw cancellationError;
          },
          (completed) => {
            if (taskId !== cachingTaskId) return;
            setCachingProgress((completed / targetWarmupCount) * 100);
          },
        );
        return taskId === cachingTaskId;
      } catch (error) {
        if (error?.name === 'WarmupCancelledError') {
          return false;
        }
        throw error;
      } finally {
        if (taskId === cachingTaskId) {
          setCaching(false);
        }
      }
    }

    async function startPlaybackAfterWarmup(frameList = frames) {
      if (isCaching) return false;
      if (!Array.isArray(frameList) || frameList.length === 0) return false;
      if (!loadedSplat || !loadedSplat.isInitialized) {
        await showFrame(currentIndex);
      }
      const warmupDone = await warmupPlaybackAssets(frameList);
      if (!warmupDone) return false;
      setPlaying(true);
      return true;
    }

    playBtn.addEventListener('click', async () => {
      if (isCaching) return;
      if (isPlaying) {
        setPlaying(false);
        return;
      }
      if (!frames.length) return;
      await startPlaybackAfterWarmup(frames);
    });
    speedSelect.addEventListener('change', () => {
      const v = Number(speedSelect.value);
      if (!Number.isFinite(v) || v <= 0) return;
      speedMultiplier = v;
      if (isPlaying) {
        stopPlayback();
        startPlayback();
      }
    });

    fovSlider.addEventListener('input', () => {
      updateFov(fovSlider.value);
    });

    progressEl.addEventListener('input', () => {
      if (!frames.length) return;
      const index = Number(progressEl.value) || 0;
      setPlaying(false);
      showFrame(index);
    });

    resetBtn.addEventListener('click', () => {
      resetViewState();
    });

    importBtn?.addEventListener('click', async () => {
      if (renderer.xr.isPresenting) {
        const xrSession = renderer.xr.getSession();
        if (xrSession) {
          await xrSession.end();
        }
      }
      showImportInterface();
    });

    updateFov(camera.fov);

    renderer.setAnimationLoop(function animate(timeMs) {
      const isInVR = renderer.xr.isPresenting;

      if (!isInVR) {
        if (shouldResetViewAfterVrExit) {
          shouldResetViewAfterVrExit = false;
          resetViewState();
        }
        resize();
        controls.update(camera);

        let isOrbiting = false;

        if (
          orbitKeyState.ArrowLeft ||
          orbitKeyState.ArrowRight ||
          orbitKeyState.ArrowUp ||
          orbitKeyState.ArrowDown
        ) {
          isOrbiting = true;
          syncOrbitFromCamera();
          if (orbitKeyState.ArrowLeft) orbitYaw += orbitSpeed;
          if (orbitKeyState.ArrowRight) orbitYaw -= orbitSpeed;
          if (orbitKeyState.ArrowUp) {
            orbitPitch = Math.min(Math.PI / 2 - 0.05, orbitPitch + orbitSpeed);
          }
          if (orbitKeyState.ArrowDown) {
            orbitPitch = Math.max(-Math.PI / 2 + 0.05, orbitPitch - orbitSpeed);
          }
          applyOrbit();
        }

        const deltaPos = camera.position.clone().sub(lastCameraPos);
        if (isOrbiting) {
          lastCameraPos.copy(camera.position);
        } else if (deltaPos.lengthSq() > 0) {
          orbitTarget.add(deltaPos);
          lastCameraPos.copy(camera.position);
        }
      } else {
        // Keep both frame and 3DGS world-fixed in VR.
        // Place window once when entering VR so the scene starts centered.
        // Keep the window plane fixed at world (0, 0, z).
        if (!vrFrameInitialized) {
          vrFrameGroup.position.set(0, 0, 0);
          vrFrameGroup.rotation.set(0, 0, 0);
          fitVrWindowToSplat();
          vrFrameInitialized = true;
          pendingVrRefit = false;
        }

        if (isPlaying && frames.length > 0 && !isCaching) {
          const nowMs = Number.isFinite(timeMs) ? timeMs : performance.now();
          if (!xrPlaybackClockInitialized) {
            xrPlaybackClockInitialized = true;
            xrPlaybackLastTimestamp = nowMs;
            xrPlaybackElapsedMs = 0;
          } else {
            const deltaMs = Math.max(0, Math.min(250, nowMs - xrPlaybackLastTimestamp));
            xrPlaybackLastTimestamp = nowMs;
            xrPlaybackElapsedMs += deltaMs;
          }

          const frameDelayMs = getNextFrameDelayMs(currentIndex, frames);
          if (!isLoadingFrame && xrPlaybackElapsedMs >= frameDelayMs) {
            xrPlaybackElapsedMs -= frameDelayMs;
            nextFrame().catch((error) => {
              console.warn('VR frame playback failed, will retry on next XR tick:', error);
            });
          }
        } else {
          resetXrPlaybackClock();
        }

      }

      renderer.render(scene, camera);
    });

    const dropZoneEl = document.querySelector('.container');
    const dropUIEl = document.querySelector('.drop-zone');
    const onDragover = function (e) {
      e.preventDefault();
      dropUIEl.classList.add('dragover');
    };
    const onDragLeave = function () {
      dropUIEl.classList.remove('dragover');
    };
    const onDrop = function (e) {
      e.preventDefault();
      dropUIEl.classList.remove('dragover');

      const files = Array.from(e.dataTransfer.files || []);
      if (files.length > 0) {
        loadSplatFiles(files);
      }
    };

    dropZoneEl.addEventListener('dragover', onDragover);
    sparkCanvasEl.addEventListener('dragover', onDragover);

    dropZoneEl.addEventListener('dragleave', onDragLeave);
    sparkCanvasEl.addEventListener('dragleave', onDragLeave);

    dropZoneEl.addEventListener('drop', onDrop);
    sparkCanvasEl.addEventListener('drop', onDrop);

    const fileInput = document.querySelector('#file-input');
    fileInput.onchange = function(event) {
      const files = Array.from(event.target.files || []);
      if (files.length) { loadSplatFiles(files); }
      event.target.value = '';
    };

    dropUIEl.addEventListener('click', () => {
      fileInput.value = '';
      fileInput.click();
    });

    function sortFilesByName(files) {
      return files.slice().sort((a, b) => {
        const aSeq = extractFrameSequence(a?.name);
        const bSeq = extractFrameSequence(b?.name);
        if (Number.isFinite(aSeq) && Number.isFinite(bSeq) && aSeq !== bSeq) {
          return aSeq - bSeq;
        }
        return String(a?.name || '').localeCompare(String(b?.name || ''), undefined, { numeric: true });
      });
    }

    const sceneCache = new Map();

    function getSceneCacheKey(dirUrl) {
      const normalized = normalizeDirectoryUrl(dirUrl);
      return `${normalized}::${maxFramesMode}`;
    }

    function createSceneFramesFromUrls(urls) {
      return limitFrames(urls).map((u, index) => {
        const name = u.split('/').pop().split('?')[0];
        const parsed = extractFrameSequence(name);
        return {
          url: u,
          name,
          timeUnits: Number.isFinite(parsed) ? parsed : index,
          file: null,
          bytes: null,
          mesh: null,
          meshPromise: null,
          bytesPromise: null,
        };
      });
    }

    async function switchToFrameList(nextFrames, {
      warmup = false,
      ensureFirstBytes = false,
      releaseOnlyIfChanged = false,
    } = {}) {
      cancelCachingTask();
      const previousFrames = frames;
      frames = nextFrames;
      currentIndex = 0;
      setPlaying(false);

      if (!releaseOnlyIfChanged || previousFrames !== frames) {
        releaseFrameListResources(previousFrames);
      }
      if (frames.length === 0) return;
      if (ensureFirstBytes) {
        await ensureFrameBytes(0, frames);
      }
      if (renderer.xr.isPresenting) {
        pendingVrRefit = true;
      }
      await showFrame(0);
      resetViewState();
      showViewerInterface();
      if (warmup) {
        await startPlaybackAfterWarmup(frames);
      }
    }

    async function loadSplatFiles(files) {
      const ordered = sortFilesByName(files);
      const loadedFrames = limitFrames(ordered.map((f) => ({
        name: f.name,
        timeUnits: Number.isFinite(extractFrameSequence(f.name)) ? extractFrameSequence(f.name) : null,
        file: f,
        bytes: null,
        mesh: null,
        meshPromise: null,
        bytesPromise: null,
      })));

      await switchToFrameList(loadedFrames, {
        warmup: true,
        ensureFirstBytes: true,
      });
    }

    var loadedSplat;
    async function setSplatFile(init) {
      const nextSplat = new SplatMesh(init);
      nextSplat.quaternion.set(1, 0, 0, 0);
      nextSplat.scale.setScalar(3);
      nextSplat.visible = false;
      scene.add(nextSplat);
      await nextSplat.initialized;
      nextSplat.visible = true;
      return nextSplat;
    }

    function isDetachedArrayBuffer(buffer) {
      if (!(buffer instanceof ArrayBuffer)) return true;
      try {
        new DataView(buffer);
        return false;
      } catch {
        return true;
      }
    }

    function hasUsableFrameBytes(frame) {
      if (!frame || !(frame.bytes instanceof Uint8Array)) return false;
      if (frame.bytes.byteLength <= 0) return false;
      return !isDetachedArrayBuffer(frame.bytes.buffer);
    }

    async function ensureFrameBytes(index, frameList = frames) {
      const frame = frameList[index];
      if (!frame) return null;
      if (hasUsableFrameBytes(frame)) return frame.bytes;
      if (frame.bytes && !hasUsableFrameBytes(frame)) {
        frame.bytes = null;
        frame.bytesPromise = null;
      }
      if (frame.bytesPromise) return frame.bytesPromise;
      frame.bytesPromise = (async () => {
        try {
          if (frame.file) {
            frame.bytes = new Uint8Array(await frame.file.arrayBuffer());
          } else if (frame.url && !frame.bytes) {
            const resp = await fetch(frame.url);
            frame.bytes = new Uint8Array(await resp.arrayBuffer());
          }
          return frame.bytes;
        } catch (e) {
          frame.bytesPromise = null;
          throw e;
        }
      })();
      return frame.bytesPromise;
    }

    async function ensureFrameMesh(index, frameList = frames) {
      const frame = frameList[index];
      if (!frame) return null;
      if (frame.mesh) return frame.mesh;
      if (frame.meshPromise) return frame.meshPromise;
      frame.meshPromise = (async () => {
        try {
          if (!hasUsableFrameBytes(frame) && (frame.file || frame.url)) {
            frame.bytes = null;
            frame.bytesPromise = null;
            await ensureFrameBytes(index, frameList);
          }
          const runtimePolicy = getRuntimeMemoryPolicy();
          const bytesForMesh = runtimePolicy.releaseBytesAfterMesh
            ? frame.bytes
            : (frame.bytes ? frame.bytes.slice() : frame.bytes);
          const mesh = await setSplatFile(
            {
            fileBytes: bytesForMesh,
            fileName: frame.name,
            },
          );
          mesh.visible = false;
          frame.mesh = mesh;
          if (runtimePolicy.releaseBytesAfterMesh) {
            frame.bytes = null;
            frame.bytesPromise = null;
          }
          return mesh;
        } catch (e) {
          frame.meshPromise = null;
          throw e;
        }
      })();

      return frame.meshPromise;
    }

    function frameCircularDistance(target, center, total) {
      const direct = Math.abs(target - center);
      return Math.min(direct, total - direct);
    }

    function releaseFrameMesh(frame) {
      if (!frame?.mesh) return;
      const mesh = frame.mesh;
      mesh.visible = false;
      scene.remove(mesh);
      if (typeof mesh.dispose === 'function') {
        mesh.dispose();
      }
      frame.mesh = null;
      frame.meshPromise = null;
    }

    function releaseFrameListResources(frameList, { releaseBytes = false } = {}) {
      if (!Array.isArray(frameList) || frameList.length === 0) return;
      for (const frame of frameList) {
        releaseFrameMesh(frame);
        if (releaseBytes) {
          frame.bytes = null;
          frame.bytesPromise = null;
        }
      }
      if (loadedSplat && !frameList.includes(frames[currentIndex])) {
        loadedSplat = null;
      }
    }

    function trimFrameMeshes(activeIndex = currentIndex, frameList = frames) {
      const { maxResidentMeshes } = getRuntimeMemoryPolicy();
      if (!Number.isFinite(maxResidentMeshes)) return;
      if (!Array.isArray(frameList) || frameList.length <= maxResidentMeshes) return;
      const loaded = [];
      for (let i = 0; i < frameList.length; i += 1) {
        if (frameList[i]?.mesh) loaded.push(i);
      }
      if (loaded.length <= maxResidentMeshes) return;

      loaded.sort((a, b) => frameCircularDistance(b, activeIndex, frameList.length) - frameCircularDistance(a, activeIndex, frameList.length));
      while (loaded.length > maxResidentMeshes) {
        const idx = loaded.shift();
        if (idx == null || idx === activeIndex) continue;
        releaseFrameMesh(frameList[idx]);
      }
    }

    function preloadFrames(activeIndex = currentIndex, frameList = frames) {
      if (!Array.isArray(frameList) || frameList.length === 0) return;
      const pending = [];
      const total = frameList.length;
      const { preloadAheadFrames } = getRuntimeMemoryPolicy();
      const preloadCount = Math.min(preloadAheadFrames, Math.max(0, total - 1));

      for (let step = 1; step <= preloadCount; step += 1) {
        const i = (activeIndex + step) % total;
        if (!frameList[i]?.mesh && !frameList[i]?.meshPromise) {
          pending.push(ensureFrameMesh(i, frameList));
        }
      }
      if (pending.length > 0) {
        Promise.allSettled(pending);
      }
    }

    let splatURL = params.get("url");

    if (splatURL) { loadSplatURL(splatURL); }


    async function loadSceneByDirectory(dirUrl) {
      const normalized = normalizeDirectoryUrl(dirUrl);
      const cacheKey = getSceneCacheKey(normalized);
      let sceneEntry = sceneCache.get(cacheKey);
      if (!sceneEntry) {
        const urls = await discoverSplatFiles(normalized);
        sceneEntry = {
          dir: normalized,
          frames: createSceneFramesFromUrls(urls),
        };
        sceneCache.set(cacheKey, sceneEntry);
      }

      await switchToFrameList(sceneEntry.frames, {
        warmup: true,
        ensureFirstBytes: true,
        releaseOnlyIfChanged: true,
      });
    }


    async function loadSplatURL(splatURL) {
      const fileName = splatURL.split("/").pop().split("?")[0];
      await switchToFrameList([
        {
          url: splatURL,
          name: fileName,
          timeUnits: Number.isFinite(extractFrameSequence(fileName)) ? extractFrameSequence(fileName) : 0,
          file: null,
          bytes: null,
          mesh: null,
          meshPromise: null,
          bytesPromise: null,
        },
      ]);
    }

    async function loadSplatURLs(urls) {
      await switchToFrameList(createSceneFramesFromUrls(urls));
    }

    // Expand a URL pattern with {start..end} into an array of URLs
    // e.g. "/data/frame_{001..050}.spz" → ["/data/frame_001.spz", ..., "/data/frame_050.spz"]
    function expandUrlPattern(input) {
      const match = input.match(/^(.*)\{(\d+)\.\.(\d+)\}(.*)$/);
      if (!match) return null;
      const [, prefix, startStr, endStr, suffix] = match;
      const start = parseInt(startStr, 10);
      const end = parseInt(endStr, 10);
      const padLen = startStr.length;
      const urls = [];
      for (let i = start; i <= end; i++) {
        urls.push(prefix + String(i).padStart(padLen, '0') + suffix);
      }
      return urls;
    }

    const SPLAT_EXTS = ['.ply', '.spz', '.splat', '.ksplat', '.sog'];
    const SCENES_API_URL = './api/scenes';
    let sceneCatalogPromise = null;

    function normalizeCatalogKey(input) {
      return normalizeDirectoryUrl(input).replace(/^\/+|\/+$/g, '');
    }

    async function loadSceneCatalog() {
      if (sceneCatalogPromise) return sceneCatalogPromise;
      sceneCatalogPromise = (async () => {
        try {
          const apiResp = await fetch(SCENES_API_URL, { cache: 'no-store' });
          if (apiResp.ok) {
            const apiPayload = await apiResp.json();
            if (apiPayload?.scenes && typeof apiPayload.scenes === 'object') {
              return apiPayload.scenes;
            }
          }
          console.warn('Dynamic scenes API returned unexpected payload.');
          return {};
        } catch (e) {
          console.warn('Failed to load dynamic scenes API:', e);
          return {};
        }
      })();
      return sceneCatalogPromise;
    }

    function extractSceneUrls(sceneConfig) {
      if (typeof sceneConfig === 'string') {
        return [sceneConfig];
      }

      if (Array.isArray(sceneConfig)) return sceneConfig.slice();
      if (!sceneConfig || typeof sceneConfig !== 'object') return [];

      if (Array.isArray(sceneConfig.urls)) {
        return sceneConfig.urls.slice();
      }

      if (typeof sceneConfig.urls === 'string') {
        return [sceneConfig.urls];
      }

      if (typeof sceneConfig.pattern === 'string') {
        return expandUrlPattern(sceneConfig.pattern) || [];
      }

      if (typeof sceneConfig.baseUrl === 'string' && Array.isArray(sceneConfig.files)) {
        const baseUrl = sceneConfig.baseUrl.endsWith('/') ? sceneConfig.baseUrl : `${sceneConfig.baseUrl}/`;
        return sceneConfig.files.map(name => `${baseUrl}${name}`);
      }

      return [];
    }

    async function discoverSplatFiles(dirUrl) {
      const key = normalizeCatalogKey(dirUrl);
      const catalog = await loadSceneCatalog();
      const sceneConfig = catalog[key];
      if (!sceneConfig) return [];
      const urls = extractSceneUrls(sceneConfig).filter(url => {
        if (typeof url !== 'string') return false;
        const lower = url.toLowerCase();
        return SPLAT_EXTS.some(ext => lower.endsWith(ext));
      });
      return limitFrames(urls);
    }

    const urlDirSelectEl = document.querySelector('.url-dir-select');
    const cacheAllBtnEl = document.querySelector('.cache-all-button');
    const cacheAllProgressEl = document.querySelector('.cache-all-progress');
    const cacheAllLabelEl = document.querySelector('.cache-all-label');
    let currentDirectory = '/';
    let selectedSceneDirectory = '';
    let cacheButtonIdleLabel = 'Cache';
    let cacheLabelAnimTimer = null;
    let cacheLabelAnimFrame = 0;
    let cacheAllLabelTextEl = null;
    let cacheAllLabelDotsEl = null;

    function ensureCacheLabelParts() {
      if (!cacheAllLabelEl) return;
      if (cacheAllLabelTextEl && cacheAllLabelDotsEl) return;
      cacheAllLabelEl.innerHTML = '';
      cacheAllLabelTextEl = document.createElement('span');
      cacheAllLabelTextEl.className = 'cache-all-label-text';
      cacheAllLabelDotsEl = document.createElement('span');
      cacheAllLabelDotsEl.className = 'cache-all-label-dots';
      cacheAllLabelDotsEl.textContent = '';
      cacheAllLabelEl.appendChild(cacheAllLabelTextEl);
      cacheAllLabelEl.appendChild(cacheAllLabelDotsEl);
    }

    function setCacheLabel(baseLabel, dots = '') {
      ensureCacheLabelParts();
      if (!cacheAllLabelTextEl || !cacheAllLabelDotsEl) return;
      cacheAllLabelTextEl.textContent = baseLabel;
      cacheAllLabelDotsEl.textContent = dots;
    }

    function stopCacheLabelAnimation() {
      if (cacheLabelAnimTimer) {
        clearInterval(cacheLabelAnimTimer);
        cacheLabelAnimTimer = null;
      }
    }

    function startCacheLabelAnimation(baseLabel) {
      stopCacheLabelAnimation();
      ensureCacheLabelParts();
      cacheLabelAnimFrame = 0;
      const dotFrames = ['', '.', '..', '...'];
      setCacheLabel(baseLabel, dotFrames[1]);
      cacheLabelAnimTimer = setInterval(() => {
        cacheLabelAnimFrame = (cacheLabelAnimFrame + 1) % 4;
        setCacheLabel(baseLabel, dotFrames[cacheLabelAnimFrame]);
      }, 350);
    }

    function setCacheButtonState({
      label = 'Cache',
      progress = 0,
      disabled = false,
      isCaching = false,
    } = {}) {
      if (isCaching) {
        startCacheLabelAnimation(label);
      } else {
        stopCacheLabelAnimation();
        setCacheLabel(label, '');
      }
      if (cacheAllProgressEl) {
        let pct = Math.max(0, Math.min(100, progress));
        if (isCaching && pct < 10) {
          pct = 10;
        }
        cacheAllProgressEl.style.width = `${pct}%`;
      }
      if (cacheAllBtnEl) {
        cacheAllBtnEl.disabled = disabled;
        cacheAllBtnEl.classList.toggle('is-caching', isCaching);
      }
    }

    function normalizeDirectoryUrl(input) {
      let dir = (input || '').trim();
      if (!dir) return '/';
      if (!dir.startsWith('/')) dir = '/' + dir;
      if (!dir.endsWith('/')) dir += '/';
      return dir;
    }

    async function discoverSubdirectories(dirUrl) {
      const normalized = normalizeDirectoryUrl(dirUrl);
      if (normalized !== '/') return [];
      const catalog = await loadSceneCatalog();
      return Object.keys(catalog).sort();
    }

    function setDirectoryOptions(baseDir, directories) {
      if (!urlDirSelectEl) return;
      const normalizedBase = normalizeDirectoryUrl(baseDir);
      const previousSelection = selectedSceneDirectory;
      urlDirSelectEl.innerHTML = '';

      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select folder...';
      urlDirSelectEl.appendChild(placeholder);

      if (directories.length === 0) {
        const empty = document.createElement('option');
        empty.value = '';
        empty.textContent = 'No folders';
        empty.disabled = true;
        urlDirSelectEl.appendChild(empty);
      } else {
        for (const name of directories) {
          const fullDir = `${normalizedBase}${name}/`;
          const option = document.createElement('option');
          option.value = fullDir;
          option.textContent = name;
          option.title = fullDir;
          urlDirSelectEl.appendChild(option);
        }
      }

      if (previousSelection) {
        const hasPrevious = Array.from(urlDirSelectEl.options).some(option => option.value === previousSelection);
        urlDirSelectEl.value = hasPrevious ? previousSelection : '';
        if (!hasPrevious) {
          selectedSceneDirectory = '';
        }
      } else {
        urlDirSelectEl.value = '';
      }
    }

    async function refreshDirectoryDropdown(baseDir = currentDirectory) {
      if (!urlDirSelectEl) return;
      currentDirectory = normalizeDirectoryUrl(baseDir);
      try {
        urlDirSelectEl.disabled = true;
        urlDirSelectEl.innerHTML = '<option value="">Loading folders...</option>';
        const dirs = await discoverSubdirectories(currentDirectory);
        setDirectoryOptions(currentDirectory, dirs);
      } catch (e) {
        console.error('Directory discovery failed:', e);
        urlDirSelectEl.innerHTML = '<option value="">Folder list unavailable</option>';
      } finally {
        urlDirSelectEl.disabled = false;
      }
    }

    async function loadFromUrlText(raw) {
      if (!raw) return;

      // 1) Try pattern expansion: /data/f_{001..050}.spz
      const patternUrls = expandUrlPattern(raw);
      if (patternUrls) {
        await loadSplatURLs(patternUrls);
        return true;
      }

      // 2) If URL has no file extension, treat as directory → discover splat files
      const lastSegment = raw.split('/').pop().split('?')[0];
      const hasExt = lastSegment.includes('.') && SPLAT_EXTS.some(ext => lastSegment.toLowerCase().endsWith(ext));
      if (!hasExt) {
        try {
          const normalized = normalizeDirectoryUrl(raw);
          const cacheKey = getSceneCacheKey(normalized);
          // Use in-memory cache first so returning to import is instant.
          if (!sceneCache.has(cacheKey)) {
            const urls = await discoverSplatFiles(normalized);
            if (urls.length === 0) {
              alert('No .ply / .spz / .splat / .ksplat / .sog files found at that URL');
              return false;
            }
            sceneCache.set(cacheKey, {
              dir: normalized,
              frames: createSceneFramesFromUrls(urls),
            });
          }
          await loadSceneByDirectory(normalized);
        } catch (e) {
          console.error('Scene load failed:', e);
          alert('Failed to load scene: ' + (e?.message || e));
          return false;
        }
        return true;
      }

      // 3) Single file URL
      const url = new URL(window.location);
      await loadSplatURL(raw);
      url.searchParams.set('url', raw);
      history.pushState(null, '', url);
      return true;
    }

    async function cacheDirectoryScene(dirUrl) {
      const normalized = normalizeDirectoryUrl(dirUrl);
      const cacheKey = getSceneCacheKey(normalized);
      const urls = await discoverSplatFiles(normalized);
      if (urls.length === 0) return false;

      let sceneEntry = sceneCache.get(cacheKey);
      if (!sceneEntry) {
        sceneEntry = {
          dir: normalized,
          frames: [],
        };
      }

      const existingByUrl = new Map(sceneEntry.frames.map(frame => [frame.url, frame]));
      sceneEntry.frames = urls.map(url => {
        const existing = existingByUrl.get(url);
        if (existing) return existing;
        const [nextFrame] = createSceneFramesFromUrls([url]);
        return nextFrame;
      });
      sceneCache.set(cacheKey, sceneEntry);

      const frameByteConcurrency = IS_IOS_DEVICE
        ? IOS_CACHE_FRAME_BYTE_CONCURRENCY
        : DESKTOP_CACHE_FRAME_BYTE_CONCURRENCY;

      await runIndexTasksWithConcurrency(sceneEntry.frames.length, frameByteConcurrency, async (i) => {
        await ensureFrameBytes(i, sceneEntry.frames);
        if (IS_IOS_DEVICE) {
          sceneEntry.frames[i].bytes = null;
          sceneEntry.frames[i].bytesPromise = null;
        }
      });
      return true;
    }

    async function cacheAllScenesFromCurrentDirectory() {
      const dirs = await discoverSubdirectories(currentDirectory);
      const targets = dirs.map(name => `${normalizeDirectoryUrl(currentDirectory)}${name}/`);
      if (targets.length === 0) {
        cacheButtonIdleLabel = 'Cache';
        setCacheButtonState({
          label: 'No scenes found',
          progress: 0,
          disabled: false,
          isCaching: false,
        });
        return;
      }

      setCacheButtonState({
        label: `Caching 0/${targets.length}`,
        progress: 0,
        disabled: true,
        isCaching: true,
      });

      const sceneConcurrency = IS_IOS_DEVICE
        ? IOS_CACHE_SCENE_CONCURRENCY
        : DESKTOP_CACHE_SCENE_CONCURRENCY;

      let done = 0;
      await runIndexTasksWithConcurrency(
        targets.length,
        sceneConcurrency,
        async (index) => {
          const dir = targets[index];
          try {
            await cacheDirectoryScene(dir);
          } catch (e) {
            console.warn('Cache scene failed:', dir, e);
          }
        },
        (completed) => {
          done = completed;
          setCacheButtonState({
            label: `Caching ${done}/${targets.length}`,
            progress: (done / targets.length) * 100,
            disabled: true,
            isCaching: true,
          });
        },
      );

      cacheButtonIdleLabel = `Cached ${done}/${targets.length}`;
      setCacheButtonState({
        label: cacheButtonIdleLabel,
        progress: 100,
        disabled: false,
        isCaching: false,
      });
    }

    urlDirSelectEl?.addEventListener('change', async () => {
      const selected = urlDirSelectEl.value;
      if (!selected) return;
      selectedSceneDirectory = normalizeDirectoryUrl(selected);
      await loadFromUrlText(selected);
      await refreshDirectoryDropdown(currentDirectory);
    });

    cacheAllBtnEl?.addEventListener('click', async () => {
      await cacheAllScenesFromCurrentDirectory();
    });

    refreshDirectoryDropdown('/');
    setCacheButtonState({
      label: cacheButtonIdleLabel,
      progress: 0,
      disabled: false,
    });

    
  </script>
  <div class="canvas-container invisible">
    <div class="viewer-window">
      <div class="viewer-stack">
        <div class="window-frame">
          <div class="logo">
            <a href="./"><img src="./pico-logo.png" alt="Spark Logo" /></a>
          </div>
          <canvas class="spark-canvas"></canvas>
        </div>
        <div class="controls">
          <div class="controls-left">
            <button class="play-button play-toggle" aria-label="Play">
              <span class="play-icon" aria-hidden="true">▶</span>
              <span class="loading-spinner" aria-hidden="true"></span>
            </button>
            <span class="caching-percent" aria-live="polite">0%</span>
          </div>
          <div class="progress-wrap">
            <span class="time time-current">00:00</span>
            <input class="progress" type="range" min="0" max="0" step="1" value="0" />
            <span class="time time-total">00:00</span>
            <span class="frame-indicator frame-indicator-progress">0/0</span>
          </div>
          <div class="controls-right">
            <span class="frame-indicator frame-indicator-actions">0/0</span>
            <select class="speed-select">
              <option value="0.5">0.5x</option>
              <option value="1" selected>1x</option>
              <option value="1.5">1.5x</option>
              <option value="2">2x</option>
              <option value="3">3x</option>
            </select>
            <div class="fov-wrap">
              <span class="fov-label">FOV</span>
              <input class="fov-slider" type="range" min="10" max="90" step="1" value="35" />
              <span class="fov-value">35°</span>
            </div>
            <button class="import-button">Import</button>
            <button class="reset-button">Reset</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="container">
    <div class="drop-container">
      <h1 class="hero-title">Pico 6DoF Video Player</h1>
      <div class="hero-logo">
        <a href="./"><img src="./pico-viewer.png" alt="Pico Viewer Logo" /></a>
      </div>
      <div class="drop-zone">Drag and drop splat files here</div>
      <input id="file-input" class="hidden" accept=".ply,.spz,.splat,.ksplat,.sog" type="file" multiple />
      <form class="url-form">
        <div class="url-row">
          <select class="url-select url-dir-select" aria-label="Folder list">
            <option value="">Select folder...</option>
          </select>
          <div class="frame-limit-wrap" title="Frame range">
            <select class="frame-limit-select" aria-label="Frame range">
              <option value="short" selected>Short (16 Frames)</option>
              <option value="medium">Medium (32 Frames)</option>
              <option value="long">Long (All Frames)</option>
            </select>
          </div>
        </div>
        <button type="button" class="cache-all-button">
          <span class="cache-all-progress" aria-hidden="true"></span>
          <span class="cache-all-label">Cache all scenes</span>
        </button>
      </form>
    </div>
  </div>
</body>
</html>
